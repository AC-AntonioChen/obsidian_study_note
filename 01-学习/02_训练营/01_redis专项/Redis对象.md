## **Redis 对象系统（The Object System）**。

理解这套系统，是掌握 Redis 核心设计思想的关键。

## 🔑 第一层抽象：`redisObject` 结构体

在 Redis 中，无论是 Key 还是 Value，它们在内存中都不是直接以字符串或整数形式存在的，而是被封装在一个统一的容器中——`redisObject` 结构体。

这个结构体是所有 Redis 对象的基石，它至少包含以下五个核心字段：

|**字段**|**作用描述**|**知识点映射**|
|---|---|---|
|`type`|**对象类型**：标识该对象属于哪种用户可见的抽象数据类型（如 `REDIS_STRING`）。|**5 大基本数据结构**|
|`encoding`|**底层编码**：标识该对象实际使用了哪种内存友好的数据结构来实现（如 `REDIS_ENCODING_ZIPLIST`）。|**性能与内存优化的核心**|
|`ptr`|**指向底层数据结构的指针**：指向实际存储数据的内存区域。|**实际数据存储**|
|`lru`|记录空闲时间或访问频率，用于内存淘汰策略（LRU/LFU）。|**内存管理**|
|`refcount`|**引用计数**：用于内存回收和共享对象机制。|**内存优化**|

### 💡 总结：`redisObject` 是所有键值对的“元数据”和“容器”。

---

## 🛠️ 第二层：`type`（抽象数据类型）

`redisObject` 中的 `type` 字段定义了我们从 Redis 外部看到的 5 大基本数据结构。这代表了 Redis 提供的**逻辑抽象**和我们可以执行的操作集合。

1. **String (字符串)**：最基本类型，可存储字符串、整数或浮点数。
    
2. **List (列表)**：有序的、可重复的元素集合。
    
3. **Hash (哈希)**：字段-值（Field-Value）的无序映射表。
    
4. **Set (集合)**：无序的、唯一的元素集合。
    
5. **ZSet (有序集合)**：带有分值（Score）的唯一元素集合，按分值排序。
    

**面试要点**：当我们在客户端执行 `TYPE key` 命令时，Redis 返回的就是这个 `type` 字段对应的值。

---

## ⚙️ 第三层：`encoding`（底层数据结构）

**`encoding`** 字段是 Redis **高性能和低内存消耗**设计的灵魂所在。

对于同一种抽象类型（`type`），Redis 可能会使用**多种底层数据结构**来实现它。Redis 会根据数据量、元素大小等条件，**自动选择**最适合当前场景的编码。

### 1. 为什么需要多种编码？

想象一下，你有一个包含 10 个字段的 Hash 对象，每个字段的值都很短。如果用一个通用的 **哈希表（Dictionary）** 来存储，会产生大量的指针和结构体开销，非常浪费内存。

Redis 的做法是：

- **小数据量**：使用 **紧凑的、内存效率高** 的底层编码。
    
- **大数据量/复杂场景**：使用 **通用但消耗内存较多** 的底层编码。
    

### 2. 核心编码及其优化

|**对象类型 (type)**|**优化编码（小数据量）**|**通用编码（大数据量）**|
|---|---|---|
|**String**|`int` (存储整数) / `embstr` (短字符串)|`raw` (长字符串)|
|**List**|`ziplist` (已废弃) / **`quicklist` (3.2+ 主力)**|`linkedlist` (已废弃)|
|**Hash**|`ziplist` (已废弃) / **`listpack` (新紧凑结构)**|`hashtable` (字典)|
|**Set**|**`intset` (整数集合)**|`hashtable` (字典)|
|**ZSet**|`ziplist` (已废弃) / **`listpack`**|`skiplist` (跳跃表) + `hashtable`|

### 3. 编码转换的机制（Encodings Switch）

编码转换是 Redis 优化机制的另一个核心。这种转换是**自动且不可逆**的：

1. **初始状态**：如果新创建的对象满足某些阈值（例如，列表元素数量少于 512 个，且单个元素小于 64 字节），Redis 会选择内存效率最高的编码，如 `intset` 或 `listpack`。
    
2. **触发升级**：一旦数据增长，**超出预设的阈值**（如新增一个元素导致 Hash 的字段数量超过 512 或某个值超过 64 字节），Redis 会立刻将该对象的底层编码**升级**为通用的、更灵活的结构（如 `hashtable`）。
    
3. **不可逆**：一旦升级完成，即使数据量减少到阈值以下，Redis 也**不会降级**，因为它需要避免频繁的结构转换带来的性能开销。
    

> 面试追问点：为什么 Redis 要用 quicklist 替代 ziplist 和 linkedlist？
> 
> 答案：quicklist 是一种结合了 ziplist 节约内存的优点和 linkedlist 易于增删操作的优点的混合结构，是 Redis List 类型目前的主力实现。

## 🎯 总结：抽象与实现的完美平衡

Redis 的对象系统成功地在两个目标之间找到了完美平衡：

1. **对外提供简洁、易用的抽象数据结构 (Type)**。
    
2. **对内使用灵活、高效的底层数据结构 (Encoding)**，通过自动切换实现高性能和低内存消耗。