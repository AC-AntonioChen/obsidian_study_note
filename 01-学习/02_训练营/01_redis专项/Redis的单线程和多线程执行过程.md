## Redis 核心请求处理流程拆解
### redis的执行步骤
一个客户端请求从进入 Redis 到返回结果，可以拆解为以下五个主要步骤：

| **步骤**            | **任务内容**                                                  | **涉及资源**          | **耗时特点**                 |
| ----------------- | --------------------------------------------------------- | ----------------- | ------------------------ |
| **1. Socket 就绪**  | 操作系统通知 $\text{epoll}$ 或 $\text{kqueue}$ 有数据可读或可写。         | $\text{CPU}$ / 内核 | 极短                       |
| **2. I/O 读取/解析**  | 从 $\text{socket}$ **读取**原始字节流，并将其 **解析** 成 Redis 内部的命令对象。 | $\text{CPU}$ (大量) | 串行瓶颈所在                   |
| **3. 命令执行**       | 根据命令对象，在 **内存** 中执行数据操作（如 $\text{GET}$、$\text{SET}$）。     | $\text{RAM}$ (内存) | 极快 ($\text{ns}/\mu s$ 级) |
| **4. I/O 写入/序列化** | 将命令执行的结果 **序列化** 成 $\text{RESP}$ 协议格式的字节流。                | $\text{CPU}$ (较多) | 串行瓶颈所在                   |
| **5. Socket 响应**  | 将序列化后的字节流 **写回** $\text{socket}$。                         | $\text{CPU}$ / 内核 | 极短                       |
### 5.0单线程与多线程
在6.0前，redis进程就只有一个主线程在工作，处理所有的事情。

| **步骤**            | **Redis 5.0 (纯单线程)**                          | **Redis 6.0+ (多线程 I/O)**                                             | **差异点**              |
| ----------------- | --------------------------------------------- | -------------------------------------------------------------------- | -------------------- |
| **1. Socket 就绪**  | 主线程通过 $\text{epoll}$ 监听和接收事件。                 | 主线程通过 $\text{epoll}$ 监听和接收事件。                                        | **无差异**              |
| **2. I/O 读取/解析**  | **主线程** **串行** 执行所有 $\text{socket}$ 的读取和命令解析。 | 主线程将 $\text{socket}$ 分发给 **$\text{N}$ 个 $\text{I/O}$ 线程** **并行** 处理。 | **读 I/O 并行化** (性能提升) |
| **3. 命令执行**       | **主线程** **串行** 执行所有数据操作。                      | **主线程** **串行** 执行所有数据操作。                                             | **无差异** (保持原子性)      |
| **4. I/O 写入/序列化** | **主线程** **串行** 执行所有结果的序列化。                    | 主线程将待发送的结果分配给 **$\text{N}$ 个 $\text{I/O}$ 线程** **并行** 处理。            | **写 I/O 并行化** (性能提升) |
| **5. Socket 响应**  | 主线程完成 $\text{socket}$ 写入。                     | $\text{I/O}$ 线程完成 $\text{socket}$ 写入。                                | **无实质差异**            |
Redis 6.0 引入的多线程机制，其本质是：
- **分流 (Offload):** 将原本占用主线程 $\text{CPU}$ 大量的 **网络 $\text{I/O}$ 相关的计算** ($\text{读取}$、$\text{解析}$、$\text{序列化}$、$\text{写入}$) 分摊到多个 $\text{I/O}$ 线程上并行执行。
    
- **提速主循环:** 使得主线程可以更快地从一个请求的 I/O 阶段脱身，进入下一个请求的 **命令执行** 阶段（第 3 步），从而大幅提升了在高并发下的整体 **吞吐量 (QPS)**。