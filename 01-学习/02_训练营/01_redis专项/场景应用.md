## 缓存
### 缓存异常场景
#### 缓存穿透
指缓存数据在数据库和redis都没有，而用户却不断发起请求。这种情况会导致请求压力打到数据库。
##### 解决措施
（1）接口层做校验，拦截住明显非法的查询（例如id<=0）
（2）根据key从缓存和数据库都没有取到的数据，写该key - null的键值对到redis，并设置短缓存时间，防止短时间暴力攻击 
（3）布隆过滤器（基于多hash的数据结构，可以快速判断某个值是否一定不存在）

#### 缓存击穿
指一条缓存数据在redis没有，但在数据库有，一般是缓存数据过期的情况，此时大量并发请求打到数据库。
##### 解决方案
（1）热点数据支持缓存续期，每次访问时更新缓存有效期：- **数据的一致性，不是靠“过期时间”来保证的，而是靠“写操作时的删除动作”来保证的。**
 （2）重建缓存加互斥锁，当线程拿到缓存发现缓存不存在就会尝试加锁，拿到锁的线程去数据库查并重建缓存，其他争抢失败的线程进行睡眠循环重试


#### 缓存雪崩
指大量缓存数据同时过期
##### 解决方案
1、缓存数据的过期时间设置随机，防止大量数据同时过期
2、重建缓存加互斥锁，当有线程竞争成功拿到锁后，负责去数据库读数据 并重建redis缓存，其他线程失败后sleep一段时间，循环重试
### 缓存一致性
#### 缓存一致性保证思路
- 简单思路：以Redis过期时间兜底，更新mysql既可，不管redis。
- 双写思路：在更新mysql后，<u>删除</u>（不是更新）redis。这种方式仍然要设置redis 的key过期时间。这样删除的结果就不需要关注了，最终一致性可以保障。
- 异步订阅binlog：业务代码只负责更新 MySQL。通过**Canal**（只负责发送消息到消息队列，具体数据怎么处理要有单独的消费服务）等中间件伪装成 MySQL 的 Slave 节点，**订阅 MySQL 的 Binlog**。  
```
1. **为了解耦核心业务逻辑**：  
    当一个写操作需要同步更新 Redis、ES、MQ 等多个下游数据源时，代码耦合度太高。通过 Binlog 订阅，业务代码只需要写 MySQL，后续同步完全异步化，降低了系统的复杂度。
    
2. **复杂的数据聚合场景（宽表缓存）**：  
    有些 Redis 缓存的数据结构很复杂，可能需要 Join 多张 MySQL 表（比如商品详情页）。如果采用‘删缓存’策略，读请求回源时数据库压力太大。利用 Binlog 可以在后台异步计算好最新的 JSON 直接覆盖写入 Redis，实现**‘读操作零延迟’**。
    
3. **对‘缓存击穿’敏感的热点数据**：  
    也就是您提到的那个视频网站的例子。对于**超高并发的热点 Key**，如果直接‘删除缓存’，可能导致数据库瞬间崩溃。Binlog 方案可以实现**‘双写覆盖’**（直接更新 Redis 而不删除），保证缓存一直存在，从而保护数据库。
    

所以，它不仅仅是为了‘稳定数据’，更是为了解决**复杂异构同步**和**热点高可用**的问题。”
```
## 分布式锁
 分布式锁就是分布式场景下的锁，比如多台不同机器上的进程，去竞争同一项资源，就是分布式锁。
### 分布式锁的特点
（1）互斥性：只有一个竞争者能获得锁
（2）抗死锁性：避免锁因为异常永远不被释放。当一个竞争者在持有锁期间内因自身原因不能主动解锁，其持有的锁也会被兜底释放
（3）对称性：同一个锁的加锁和解锁者需要是同一个竞争者
（4）可靠性：需要有一定程度的异常处理能力和容灾能力
#### 分布式锁的实现
redis实现是应用最多的一种。
![image.png](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20251210000653.png)

- 使用value保障其他线程不会意外释放不属于自己线程的锁
- lua脚本保障获取锁 和 删除锁的这个操作整体的原子性
#### 可靠性保障
单机模式下，如果 Redis 节点挂掉：
- **服务不可用**：所有依赖锁的业务阻塞或报错。
- **锁丢失**：内存数据丢失，可能导致超卖或并发脏数据。
##### 方案1：主从容灾 + 哨兵模式 (High Availability)
###### 架构原理

- **主从复制 (Master-Slave)**：
    - Master 处理写请求（加锁）。
    - Slave 通过 RDB（全量）+ repl_buf（增量）或 AOF 同步数据。
- **哨兵 (Sentinel)**：
    - 监控 Master 状态。
    - Master 宕机后，自动选举一个 Slave 晋升为新 Master。
    - **解决痛点**：无需人工介入，自动化容灾。
    ![](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20251210191627.png)
但哨兵模式不能保障分布式锁的强一致性，会出现锁丢失的情况。
例如：
1. Client A 在 Master 获取锁成功。
2. **异步复制延迟**：Master 还没来得及把锁数据同步给 Slave。
3. **Master 宕机**。
4. Sentinel 提升 Slave 为新 Master（此时新 Master 只有旧数据，**没有锁信息**）。
5. Client B 向新 Master 申请锁 -> **成功**。
6. **结果**：Client A 和 Client B 同时持有锁 -> **互斥失效**。
##### 多机部署 + Redlock 算法 (Consistency)
**去中心化**：（部署N个，一般是奇数个比如5）完全独立的redis master节点（无主从关系）
**过半机制**：超过半数节点同意即为成功
###### 加锁流程
1. 获取当前时间戳。
2. 按顺序依次向 5 个节点申请锁（使用相同的 Key 和 Value）。
    - 注意：设置较短的网络超时时间，防止在宕机节点上卡住。
3. **校验成功条件（必须同时满足）**：
    - **数量达标**：至少在 
        ```
        N/2+1N/2+1
        ```
         (即 3 个) 节点上加锁成功。
    - **时间达标**：(当前时间 - 开始时间) < 锁的有效时间。
4. 如果成功，锁的实际有效时间 = 原有效时间 - 消耗时间。
5. 如果失败，向所有节点发起**解锁**请求。
######  优缺点

- **优点**：容忍 
    
    ```
    N/2N/2
    ```
    
     个节点宕机，解决了主从切换丢锁问题。
    
- **缺点**：部署运维复杂、性能略有下降、严重依赖服务器时钟同步。
    
- 工程实践：Java 中直接使用 Redisson 的 RedissonRedLock。

#### 分布式系统的三大困境NPC问题
N：Network Delay（网络延迟）当分布式锁获得返回包的时间过长，此时可能虽然加锁成功，但是已经时过境迁，锁可能很快过期。RedLock算了做了些考量，也就是前面所说的锁剩余持有时间，需要减去请求时间，如此一来，就可以一定程度解决网络延迟的问题。
P:Process Pause (进程暂停) 比如发生GC，获取锁之后GC了，处于GC执行中，然后锁超时
![image.png](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20251210201632.png)
C: Clock Drift (时钟漂移)
如果竞争者A，获得了RedLock，在5台分布式机器上都加上锁。为了方便分析，我们直接假设5台机器都发生了时钟漂移，锁瞬间过期了。这时候竞争者B拿到了锁，此时A和B拿到了相同的执行权限。
根据上述的分析，可以看出，RedLock也不能抗住NPC的挑战，因此，单单从分布式锁本身出发，完全可靠是不可能的。要实现一个相对可靠的分布式锁机制，还是需要和业务的配合，业务本身要幂等可重入，这样的设计可以省却很多麻烦。
## 秒杀
削峰、限流、异步、补偿
