### 
#### 1. 缓存穿透 (Cache Penetration)

- **场景**：  
    某个黑客故意请求 id = -1 或者 id = 99999999（库里根本没有）。  
    请求先查 Redis -> 没有 -> 查 MySQL -> 也没有 -> **直接返回空，不写入 Redis**。  
    下次他又发一万次这种请求，数据库每一次都要挨揍，最后可能挂掉。
    
- **解决方案**：
    
    - **基础版**：**缓存空对象**。哪怕 MySQL 返回 null，我也往 Redis 存个 null，设个短一点的过期时间（TTL）。
        
    - **进阶版（大厂必考）**：**布隆过滤器 (Bloom Filter)**。  
        在访问 Redis 之前，先加一道屏障（布隆过滤器）。它说“没有”，那就一定没有，直接拒绝请求；它说“有”，再去查 Redis。能拦住 99% 的无效请求。
        

#### 2. 缓存击穿 (Cache Breakdown)

- **场景**：  
    刚才讲的“红烧肉”案例。微博热搜第一条，突然过期了。几亿流量瞬间压到数据库。  
    **注意**：它和雪崩的区别在于，击穿是**针对某一个特定 Key** 的。
    
- **解决方案**：
    
    - **互斥锁 (Mutex Lock)**：排队查库，强一致性。（刚才讲的 setnx）。
        
    - **逻辑过期 (Logical Expiration)**：永不过期，异步重建，高可用性。
        

#### 3. 缓存雪崩 (Cache Avalanche)

- **场景**：
    
    - **情况 A**：你设置缓存时，给 100 万个商品都设了 TTL = 1小时。结果 1 小时后，这 100 万个 Key **同时过期**。数据库瞬间面对全部商品的查询压力。
        
    - **情况 B**：Redis 服务器直接**宕机**了，所有流量全部直达数据库。
        
- **解决方案**：
    
    - **针对过期（最常用）**：**TTL + 随机值**。给每个 Key 的过期时间加一个随机数（比如 1~5 分钟）。让它们“慢慢过期”，别挤在一起。
        
    - **针对宕机**：搭建 **Redis 高可用集群**（Sentinel 哨兵或 Cluster 集群），保证 Redis 挂不掉。
        
    - **兜底策略**：**限流降级**（Sentinel/Hystrix）。如果 Redis 真的崩了，通过限流让一部分请求直接返回“系统繁忙”，保住数据库别被压死。
        

---

### 📊 终极对比表（脑图记忆）

|   |   |   |   |   |
|---|---|---|---|---|
|痛点|发生原因|数据状态|核心特征|最佳解决方案|
|**缓存穿透**|恶意查询不存在的数据|Redis无，DB无|**穿透两层**，直击数据库|1. 缓存空值<br>2. **布隆过滤器**|
|**缓存击穿**|热点 Key 过期|Redis无，DB有|**单点**高并发压垮 DB|1. **互斥锁**<br>2. **逻辑过期**|
|**缓存雪崩**|1. 只有 Key 集中过期<br>2. Redis 宕机|Redis无，DB有|**大面积**失效|1. **随机 TTL**<br>2. Redis 集群<br>3. 服务降级限流|

---