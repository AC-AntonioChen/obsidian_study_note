## 1 Redis
### 1.1 redis对象
#### 1.1.1 set一个已有的数据会发生什么
会覆盖原有的值，同时会覆盖或者擦除键的过期时间。
#### 1.1.2 浮点型在string中用什么表示
对象类型上用String表示，底层数据结构使用embstr或raw编码格式
#### 1.1.3 string可以有多大
512mb。redis 设计上并不是为了存储大文件的，大文件会影响到持久化和网络通信效率，因此人为设置了这个上限值
#### 1.1.4 redis字符串是怎么实现的
对象类型String ，通常有三种底层数据结构（encoding），int，embstr和raw格式。
当字符串内容为小于long可表示范围的整形数字时，采取int结构
当字符串内容小于等于44字节时，采取embstr结构，此时，描述字符串信息的redisobject和存储内容的sds在内存中为一片连续空间。
当字符串内容大于44字节时，采取raw格式，此时，描述字符串信息的redisobject和存储内容的sds在内存中分开存储，由redisobject的ptr指针维护关联关系
#### 1.1.5 为什么embstr的阈值是44
（1）redis使用jemalloc 作为内存分配器
（2）jemalloc用于分配的最小内存单位是64字节，embstr设计目的就是为了分配效率，所以embstr最多也就只能占一个内存单元。
embstr由redisobject和sds构成，其中redisobject需要16字节，分别是4bit对象类型，4bit底层数据结构类型，24bit lru，32bit refcount，64bit指针（取各类os指针最大值），共128bit，共16字节；sds的结构需要3字节，一字节字符串实际使用长度，一字节\0结束符，一字节字节串分配的长度，一字节flag（存储 SDS 的类型）。所以剩下64-20=44
#### 1.1.6 为什么EMBSTR曾经的阈值是39吗？
3.2版本以前sds结构只有一种，非数据字段占据了8个字节。
后面sds分为sdshdr5(这个结构不被使用）、sdshdr8、sdshdr16、sdshdr32、sdshdr64，EMBSTR使用sdshdr8节约了6个字节，但多引入了一个flags字段占据1字节，所以相比3.2版本之前的SDS多了5个字节，
#### 1.1.7 sds有什么用？
（1）sds包含已使用容量字段 len，相比c原生字符串需要on时间复杂度计算，sds获取内容长度只需要o1
（2）sds有预留空间，再扩容时如果预留空间足够，就不用再重新分配内存，缩容时也可以将减少的空间先保存下来，后续使用
（3）c原生字符串使用\0作为字符串结束标准，而sds不再以\0判断，而是改成len字段判断，所以sds二进制安全，还可以存储二进制数据。
### 1.2 List
#### 1.2.1 List 完全是先入先出吗
#### 1.2.2 怎么获得list指定范围内的数据
#### 1.2.3 List如何移除特定值的数据
#### 1.2.4 List对象底层编码方式是什么
#### 1.2.5 Linkedlist编码下 查询节点个数的时间复杂度是多少

#### 1.2.6 ZipList有什么优点
对比Linkedlist，压缩列表是连续的内存区域。节约内存，方便一次性分配，遍历时局部性更强。
#### 1.2.7 Ziplist是怎么压缩数据的
ziplist 结构
```
<zlbytes><zltail><zllen><entry><entry>...<entry><zlend>
<zlbytes> 是ziplist占用的总字节数
<zltail>是存储尾部entry的起始地址-ziplist起始地址，方便o（1）复杂度跳到尾部做rpush rpop
<zllen> 存储ziplist中包含的entry数量
```
entry 的数据结构
```
是<prevlen><encoding><entry-data>
prevlen 变长存储前一entry长度
encoding 变长存储当前Entry数据类型和长度
entry-data 数据本身
```



#### 1.2.8 ZipList下 list可以从后往前遍历吗
可以，list是双端数据结构，哪种底层编码都可以从后往前遍历。
ziplist的每个entry都保存了上一个entry的prevlen

#### 1.2.9 ZipList 下 List如何从前往后遍历
可以，list是双端数据结构，哪种底层编码都可以从前往后遍历。

#### 1.2.10 ZipList  

### 1.3 Set
#### 1.3.1 set是有序的吗
intset 有序（由小至大排序），hashtable无序
#### 1.3.2 如何查看set所有成员
smembers key
#### 如何查看set中成员个数
scard key
#### 如何求set并集和交集
并集：sunion key1 ...
交集：sinter key1 key2 
#### set编码有哪些
intset和hashtable
当set 元素都是整数且元素个数不超512时，使用intset，否则使用hashtable（字典编码）
#### set为什么要用两种编码
intset是一个紧凑的有序数组，只存储元素本身，在数据量小时节约内存。
元素数量变大会使用字典编码，相比intset的o(logN)的查找速度，查找元素更快，只需要o(1)。


### Hash
#### 如何查看hash所有成员，如何查找某个成员
hgetall key
hget key subkey
#### 如何查看hash中成员个数
hlen key
#### hash编码方式
个数少于512且kv都小于64字节时采用ziplist，查找复杂度on
超过时使用hashtable。查找时间复杂度o1
#### hash查找某个key的平均时间复杂度是什么
ziplist on
hashtable o1
#### hash为什么要用两种编码方式
在hash内容小时 使用紧凑内存的数据结构减少内存占用
在hash内容多时，使用hashtable保障查找速度
#### hashtable 查找元素**总数**的平均时间复杂度是多少
O1，hashtable有used字段
#### 一个数据在hashtable中的存储位置是怎么计算的
通过哈希函数计算其所在的slot，index = key哈希值（MurmurHash2哈希算法） & sizemask（哈希表数组大小-1）。
如果所在位置的key与待查找的key不一样，发生哈希冲突，再往该slot的链表上找
#### hashtable怎么扩容
渐进式rehash扩容。
hashtable里有两个表，初始数据存在0号表上，当触发扩容时，首先在1号表上申请大于等于used两倍的最近

