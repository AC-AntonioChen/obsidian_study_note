## 1 Redis
### 1.1 redis对象
#### 1.1.1 set一个已有的数据会发生什么
会覆盖原有的值，同时会覆盖或者擦除键的过期时间。
#### 1.1.2 浮点型在string中用什么表示
对象类型上用String表示，底层数据结构使用embstr或raw编码格式
#### 1.1.3 string可以有多大
512mb。redis 设计上并不是为了存储大文件的，大文件会影响到持久化和网络通信效率，因此人为设置了这个上限值
#### 1.1.4 redis字符串是怎么实现的
对象类型String ，通常有三种底层数据结构（encoding），int，embstr和raw格式。
当字符串内容为小于long可表示范围的整形数字时，采取int结构
当字符串内容小于等于44字节时，采取embstr结构，此时，描述字符串信息的redisobject和存储内容的sds在内存中为一片连续空间。
当字符串内容大于44字节时，采取raw格式，此时，描述字符串信息的redisobject和存储内容的sds在内存中分开存储，由redisobject的ptr指针维护关联关系
#### 1.1.5 为什么embstr的阈值是44
（1）redis使用jemalloc 作为内存分配器
（2）jemalloc用于分配的最小内存单位是64字节，embstr设计目的就是为了分配效率，所以embstr最多也就只能占一个内存单元。
embstr由redisobject和sds构成，其中redisobject需要16字节，分别是4bit对象类型，4bit底层数据结构类型，24bit lru，32bit refcount，64bit指针（取各类os指针最大值），共128bit，共16字节；sds的结构需要3字节，一字节字符串实际使用长度，一字节\0结束符，一字节字节串分配的长度，一字节flag（存储 SDS 的类型）。所以剩下64-20=44
#### 1.1.6 为什么EMBSTR曾经的阈值是39吗？
3.2版本以前sds结构只有一种，非数据字段占据了8个字节。
后面sds分为sdshdr5(这个结构不被使用）、sdshdr8、sdshdr16、sdshdr32、sdshdr64，EMBSTR使用sdshdr8节约了6个字节，但多引入了一个flags字段占据1字节，所以相比3.2版本之前的SDS多了5个字节，
#### 1.1.7 sds有什么用？
（1）sds包含已使用容量字段 len，相比c原生字符串需要on时间复杂度计算，sds获取内容长度只需要o1
（2）sds有预留空间，再扩容时如果预留空间足够，就不用再重新分配内存，缩容时也可以将减少的空间先保存下来，后续使用
（3）c原生字符串使用\0作为字符串结束标准，而sds不再以\0判断，而是改成len字段判断，所以sds二进制安全，还可以存储二进制数据。
### 1.2 List
#### 1.2.1 List 完全是先入先出吗
#### 1.2.2 怎么获得list指定范围内的数据
#### 1.2.3 List如何移除特定值的数据
#### 1.2.4 List对象底层编码方式是什么
#### 1.2.5 Linkedlist编码下 查询节点个数的时间复杂度是多少

#### 1.2.6 ZipList有什么优点
对比Linkedlist，压缩列表是连续的内存区域。节约内存，方便一次性分配，遍历时局部性更强。
#### 1.2.7 Ziplist是怎么压缩数据的
ziplist 结构
```
<zlbytes><zltail><zllen><entry><entry>...<entry><zlend>
<zlbytes> 是ziplist占用的总字节数
<zltail>是存储尾部entry的起始地址-ziplist起始地址，方便o（1）复杂度跳到尾部做rpush rpop
<zllen> 存储ziplist中包含的entry数量
```
entry 的数据结构
```
是<prevlen><encoding><entry-data>
prevlen 变长存储前一entry长度
encoding 变长存储当前Entry数据类型和长度
entry-data 数据本身
```



#### 1.2.8 ZipList下 list可以从后往前遍历吗
可以，list是双端数据结构，哪种底层编码都可以从后往前遍历。
ziplist的每个entry都保存了上一个entry的prevlen

#### 1.2.9 ZipList 下 List如何从前往后遍历
可以，list是双端数据结构，哪种底层编码都可以从前往后遍历。

#### 1.2.10 ZipList  

### 1.3 Set
#### 1.3.1 set是有序的吗
intset 有序（由小至大排序），hashtable无序
#### 1.3.2 如何查看set所有成员
smembers key
#### 如何查看set中成员个数
scard key
#### 如何求set并集和交集
并集：sunion key1 ...
交集：sinter key1 key2 
#### set编码有哪些
intset和hashtable
当set 元素都是整数且元素个数不超512时，使用intset，否则使用hashtable（字典编码）
#### set为什么要用两种编码
intset是一个紧凑的有序数组，只存储元素本身，在数据量小时节约内存。
元素数量变大会使用字典编码，相比intset的o(logN)的查找速度，查找元素更快，只需要o(1)。


### Hash
#### 如何查看hash所有成员，如何查找某个成员
hgetall key
hget key subkey
#### 如何查看hash中成员个数
hlen key
#### hash编码方式
个数少于512且kv都小于64字节时采用ziplist，查找复杂度on
超过时使用hashtable。查找时间复杂度o1
#### hash查找某个key的平均时间复杂度是什么
ziplist on
hashtable o1
#### hash为什么要用两种编码方式
在hash内容小时 使用紧凑内存的数据结构减少内存占用
在hash内容多时，使用hashtable保障查找速度
#### hashtable 查找元素**总数**的平均时间复杂度是多少
O1，hashtable有used字段
#### 一个数据在hashtable中的存储位置是怎么计算的
通过哈希函数计算其所在的slot，index = key哈希值（MurmurHash2哈希算法） & sizemask（哈希表数组大小-1）。
如果所在位置的key与待查找的key不一样，发生哈希冲突，再往该slot的链表上找
#### hashtable怎么扩容
渐进式rehash扩容。
hashtable里有两个表，初始数据存在0号表上，当触发扩容时，首先在1号表上申请大于等于used两倍的最近二次幂空间。进入rehash阶段，在rehash进行期间，标记为rehashidx将从0开始，每次对字典的键值对进行crud操作后，都会将rehashidx位置的元素迁移到一号表，并将rehashidx+1，此外redis也有专门的函数，会被定期执行去推进这个rehash进度。最终0号表的元素都会被迁移到1号表上，之后1号表会被设置为0号表，接着在1号表的位置创建一个新的空白表，rehashidx置为0；
#### hashtable怎么缩容
也是渐进式rehash操作。
首先为一号表分配空间，空间大小取决于缩容前used大小。如果used小于最小值4，那么就用4，如果大于4，那么大于原来used的最近二次幂值。
在rehash进行期间，rehashidx从0开始，每次对字典的键值对执行crud后，都会将rehashidx位置的值从零号表迁移到一号表，直到所有值迁移完毕后，将一号表置为0号表，在1号表位置创建一个新的空白表。
#### 什么时候hashtable会缩容和扩容
hashtable的缩容扩容由负载因子决定，负载因子=键值对数量/哈希表大小used
扩容会在以下两个条件之一被满足时开始：
（1）当没有进行BGSAVE（RDB的一种持久化命令）或BGREWRITEAOF（AOF的一种持久化命令），且负载因子大于等于1
（2）当正在进行BGSAVE或BGREWRITEAOF，且负载因子大于等于1
缩容：当哈希表的负载因子小于0.1
### Zset（有序集合，带有分值用于排序）
#### 跳表是什么，和普通链表区别
多了多级索引的链表，可以实现o logn的查找效率
#### 跳表的查找过程
从高级索引往后查找，如果下个节点的数值比目标节点小，则继续找，否则不跳过去，而是用下级索引往下找。
#### zset怎么添加元素，怎么移除元素
zadd zrem
#### Zset如何从大到小查找范围
zrevrange key 
#### Zset有几种编码格式
ziplist（基于内存连续的数组，查找on，插入on，删除on，范围查询on）。仅当所有元素小于128且所有元素均不大于64字节使用 ；
skiplist+hashtable

| **操作类型**                  | **具体操作示例**                  | **查找/涉及的结构**              | **平均时间复杂度**             |
| ------------------------- | --------------------------- | ------------------------- | ----------------------- |
| **按 Member 查找 Score**     | `ZSCORE key member`         | 哈希表 (HT)                  | $O(1)$                  |
| **按 Member 查找 Rank (排名)** | `ZRANK key member`          | 哈希表 (HT) + 跳跃表 (Skiplist) | $O(\log N)$             |
| **范围查询 (按 Score)**        | `ZRANGEBYSCORE key min max` | 跳跃表 (Skiplist)            | $O(\log N + M)$         |
| **范围查询 (按 Rank)**         | `ZRANGE key start stop`     | 跳跃表 (Skiplist)            | $O(\log N + M)$  M指范围大小 |
| **插入/更新元素**               | `ZADD key score member`     | 哈希表 (HT) + 跳跃表 (Skiplist) | $O(\log N)$             |
| **删除元素**                  | `ZREM key member`           | 哈希表 (HT) + 跳跃表 (Skiplist) | $O(\log N)$             |
#### zset查找节点总数的平均时间复杂度是多少
o1，有len 字段
#### 为什么zset用ht+跳表
让zset拥有两种数据结构的优势，zset执行范围操作时，跳表效率高，只需要；zset需要根据成员查找分值时，ht只需要o1而不是ologn
#### zset为什么用跳表而不是B+树
B+树本质上是多叉树，是多路平衡查找树，为磁盘设计的，核心设计目标是降低树的层数，减少磁盘IO次数。因为磁盘IO较慢。
redis是内存数据库，内存访问速度本来就很快，层高低带来的IO优势不明细，跳表比B+树实现简单，内存开销更小（B+树需要存很多索引值），且B+树插入的时候可能触发复杂的节点分裂跟树平衡操作
#### zset为什么用跳表而不是红黑树
红黑树是自平衡二叉查找树。
（1）跳表实现简单维护简单
（2）zset核心场景是范围查询，这种情况下跳表的内存使用，缓存局部性不比红黑树差

### redis底层
#### SET a 100 ex 60之后，此时这个过期信息是存储在哪里的？
如果添加了对键a设置了过期时间，则会立马将其key添加到过期字典中，并存储对应时间戳
#### redis

### 缓存
#### 缓存一致性问题是什么
redis作为mysql的缓存，如果mysql更新了，redis数据怎么保持跟mysql最终一致，这就是缓存一致性问题。
#### Redis做旁路缓存，如果MySQL更新了，应该怎么办
我在项目中使用过期时间来兜底，并且在更新DB后删除缓存来提升一致性的方式。另外，在做方案设计时候我还考虑过订阅binlog的方式，但这种方案额外引入了消费服务，成本太高而收益不足，所以还是选择了前者。
我也调研过业界一些团队，包括腾讯云x团队，字节跳动飞书团队，在大部分场景也是相同的选择，甚至一部分连删除都不用，本身对缓存一定程度不一致的容忍还是有的。
#### 你认为什么情况下，适合用订阅binlog的方式
这种模式更像是同步数据，其实比较适合缓存很长时间过期、或者不过期的场景，举个简单的例子，如果有一个视频网站，有几个展示视频,他们的基本信息流量很大，但是这几个视频的信息基本不会变动，是稳定的，就可以用这种方式。