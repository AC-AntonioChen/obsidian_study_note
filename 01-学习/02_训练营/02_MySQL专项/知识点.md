### 事务隔离级别实现
#### ACID
1. **原子性 (Atomicity)**：要么成功要么失败。👉 **Undo Log** 保证。
    
2. **持久性 (Durability)**：断电也不丢数据。👉 **Redo Log** 保证。
    
3. **隔离性 (Isolation)**：并发互不干扰。👉 **MVCC + 锁** 保证（今天的重点）。
    
4. **一致性 (Consistency)**：最终目标，由上面三个共同保证。

#### 并发典型问题
1. **脏读 (Dirty Read)**：读到了你**还没提交**的数据。
2. **不可重复读 (Non-repeatable Read)**：在一个事务里，两次读同一个数据，结果**不一样**。
3. **幻读 (Phantom Read)**：在一个事务里，两次查询**记录数量**不一样。


#### 读视图 Read View 
- 每行数据库数据都有两个隐藏字段：trx_id（谁改的）和 roll_pointer（指向上一个版本的 Undo Log）。
Read View 包含四个关键信息：
    - m_ids：此刻活跃（未提交）的事务 ID 列表。
    - min_trx_id：活跃事务里最小的 ID。
    - max_trx_id：下一个应该分配的事务 ID
    - creator_trx_id：我自己的 ID。
    
1. **Read View 是什么**：内存里的**“可见性判断依据”**，不是查出来的表。
    
2. **Select 什么时候生成** Read View ：
    
    - **RC 级别**：**每次** Select 都生成新的（不论死活，只看最新）。
        
    - **RR 级别**：**第一次** Select 生成，后面一直复用。
        
3. **Update 不看 Read View**：Update 永远强制读取**最新**数据（当前读），跟 Read View 没关系。
#### 隔离级别
（1）读未提交 RU：直接读最新数据
（2）读已提交 RC：**每次**执行 Select 语句，都**重新生成**一个 Read View。（所以能看到别人刚提交的变化）
（3）可重复读 RR：**启动事务时**生成一个 Read View，**整个事务期间复用**它。（所以别人怎么改，我都只看最开始的快照）
（4）串行化 Serial：加读写锁，排队执行。最安全但最慢。