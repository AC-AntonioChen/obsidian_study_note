### 第一梯队：决胜关键（必须看）

#### 1. type (访问类型) —— **性能的风向标**

这是最重要的字段，它告诉你 MySQL 是**怎么找数据的**。  
你需要背下这个性能顺序（从上到下，性能由高到低，**越往下越危险**）：

- **system / const**：**最好**。通过主键或唯一索引一次就找到了（比如 WHERE id = 1）。
    
- **eq_ref**：**极好**。通常出现在连表查询（Join）中，使用主键或唯一索引关联。
    
- **ref**：**不错**。使用了普通索引（非唯一），或者联合索引的最左前缀。这是我们平时调优的目标。
    
- **range**：**及格线**。索引范围扫描。比如 > < >= <=，BETWEEN，IN。如果连 range 都达不到，SQL 就要优化了。
    
- **index**：**警惕**。全索引扫描（Full Index Scan）。就是刚才我们讨论的“矮子里拔将军”，虽然没回表，但也扫描了整棵索引树。
    
- **ALL**：**灾难**。全表扫描（Full Table Scan）。如果数据量大，必须优化。
    

> **面试话术**：  
> “拿到执行计划，我首先看 type。我的底线是至少达到 **range** 级别，最好能优化到 **ref**。如果是 ALL 或 index，通常意味着索引失效或需要新建索引。”

---

#### 2. Extra (额外信息) —— **魔鬼在细节**

这里藏着 MySQL 的“内心戏”。有些词出现代表**极好**，有些词出现代表**必须立刻修复**。

- **红榜（好消息）**：
    
    - **Using index**：**满分**。使用了**覆盖索引**，不需要回表。这是查询优化的最高境界。
        
    - Using index condition：用了 **ICP（索引下推）**，前面我们刚讲过，虽然回表了，但已经尽力了。
        
- **黑榜（坏消息 - 必须干掉）**：
    
    - **Using filesort**：**严重**。MySQL 无法利用索引完成排序，必须在内存（或磁盘）中进行额外的排序操作。CPU 飙升的元凶。
        
        - 对策：调整索引，把 ORDER BY 的字段加入联合索引。
            
    - **Using temporary**：**致命**。使用了临时表保存中间结果。常见于 GROUP BY 或 DISTINCT 没走索引。
        
        - 对策：同上，利用索引的有序性消除临时表。
            

---

#### 3. key (实际使用的索引)

- **含义**：MySQL **最终决定**用了哪个索引。
    
- **关注点**：
    
    - 如果为 NULL，说明没走索引（或者走了全表扫描）。
        
    - 对比 possible_keys（可能用到的索引）和 key。如果 possible_keys 有值但 key 是 NULL，说明 MySQL 觉得走索引不如全表扫描快（可能是数据分布问题）。
        

---

### 第二梯队：辅助判断（加分项）

#### 4. rows (扫描行数)

- **含义**：MySQL **估计**需要扫描多少行才能找到目标数据。
    
- **注意**：这不是精确值，是个统计估算值。
    
- **判断**：越少越好。如果你查 1 行数据，rows 是 10000，那肯定索引没建好或者区分度太低。
    

#### 5. key_len (索引使用的字节数) —— **高手必看**

这个属性在**联合索引**分析中价值连城！它能告诉你**联合索引到底用到了哪几列**。

- **场景**：联合索引 (a, b, c)。
    
    - a 是 int (4字节)，b 是 int (4字节)，c 是 int (4字节)。(假设允许 NULL，通常 +1 字节)。
        
    - 如果 key_len = 5 (4+1)，说明**只用了 a**。
        
    - 如果 key_len = 10 (4+1 + 4+1)，说明**用了 a 和 b**。
        
- **面试价值**：
    
    > “当我发现联合索引效果不佳时，我会计算 key_len 来推断最左匹配原则是否在中间某个字段**断掉**了，从而调整 SQL 写法或索引顺序。”
    

---

### 总结：一套面试“组合拳”

如果面试官让你分析一个慢查询，你可以按这个套路来表演：

1. **先看 type**：确认是不是 ALL，如果是，马上建索引。
    
2. **再看 key**：确认有没有走错索引（有时候 MySQL 会抽风选错）。
    
3. **重点看 Extra**：
    
    - 有没有 Using filesort？有就优化排序。
        
    - 有没有 Using index？没有的话，能不能把 SELECT * 里的字段加到索引里做成覆盖索引？
        
4. **最后看 rows 和 key_len**：微调索引顺序，检查联合索引的利用率。
    

---