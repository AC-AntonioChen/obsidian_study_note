

## 存储引擎
### 说一说执行一条查询 SQL 语句的全过程

```plantuml
@startuml
title SQL 查询执行流程（Activity Diagram）

start

partition "Server层" {
  :连接器\n(建立连接、初始权限校验);
  if (是否启用查询缓存？Mysql8后移除) then (是)
    :查询缓存命中则直接返回结果;
    stop
  else (否)
    :分析器\n(词法/语法分析);
    :优化器\n(索引选择、联表顺序、生成执行计划);
    :执行器\n(再次权限校验、调度执行计划);
  endif
}

partition "存储引擎层" {
  :存储引擎（如 InnoDB）\n读取/写入数据;
}

:执行器将结果返回客户端;

stop
@enduml

```

### MySQL 存储引擎有哪些？各自有什么区别?
mysql的存储引擎有MyISAM和InnoDB跟Memory等，一般常用的都是InnoDB，支持事务，锁粒度支持到行级别，支持外键，聚簇索引结构，也就是数据和主键索引在一起，查询性能相对MyISAM慢些。
MyISAM不支持事务，锁粒度只能到表级，不支持外键，是非聚簇索引，也就是索引和数据是分开的，查询性能相对快些，更新性能则比较差，适合读多写少。
Memory是将数据存储到内存中，读写快但是不具备持久性，适合临时存储。
### MyISAM 和 InnoDB 存储引擎有什么区别?
InnoDB 引擎和 MyISAM 引擎在数据存储上有很大区别，InnoDB 引擎数据存储的方式采用的是索引组织表，在索引组织表中，数据即索引，索引即数据，因此表数据和索引数据都存储在同一个文件中。MyISAM 引擎数据存储的方式采用的是堆表，在堆表的组织结构中，数据和索引分开存储，因此表 数据和索引数据会分别放在两个不同的文件中存储，索引组织表有两个优势：
·在索引组织表将索引和数据保存在同一个 B+树中，相比非聚簇索引每次查询都需要回表，因此从聚簇索引中获取数据比非聚簇索引更快，查询数据会更快
·在索引组织表中，如果记录发生了修改，则其他索引无须进行维护，除非记录的主键发生了修改，而当堆表的数据发生改变且位置发生了变更，那么所有索引中的地址都要更新，这非常影响性能。
另外，InnoDB 引擎支持行级锁和事务，而 MyISAM 引I擎都不支持，只支持表锁。
### `CHAR` 和 `VARCHAR` 有什么区别?
char是固定长度的字符串类型。在db中占用固定的存储空间，如果存储的字符串小于定义的长度，系统会自动用空格填充。
varchar是可变长度的字符串类型，实际存储时只占用实际字符串长度的空间，例如定义varchar(10)存储五字节字符串，那么只会占用5字节的存储空间，并且还会额外用1-2字节来存储"可变长字符串的长度"的空间。
从CPU角度 理论上char比varchar更快，少了长度处理的运算，但如果innodb buffer pool（位于内存）小于表大小时，也就是需要触发磁盘读写检索数据，那么varchar比char短，反而性能高。
## 索引结构
### MySQL 有哪些索引类型?
MySql支持B+树索引，哈希索引、全文索引这三种类型。我们业务常用的是B+树索引，因为它是innodb引擎默认使用的索引类型，支持排序、分组、范围查询、模糊查询等功能
### InnoDB 引擎的索引数据结构是什么?
Innodb使用的是B+树作为索引的数据结构，它的特点有
（1）InnoDB 存储引擎的主键索引B+树的非叶子节点只存放索引的键值跟指向子节点的指针列表，不存储实际的数据。叶子节点存储索引键值跟行数据，所以innodb的主键索引属于聚簇索引
（2）叶子结点列表：所有叶子节点用指针相连接，形成一个双向链表，支持快速的顺序访问和范围查询
（3）平衡树结构：所有叶子节点处于同一层，树的高度平衡，保证任何数据记录的查找插入删除和更新操作的路径长度相同，稳定性好
### 为什么索引用 B+ 树，而不用红黑树?
（1）主要原因是红黑树是二叉树而B+是n叉，因此数据多时，红黑树的树高会比B+树高多不少层，这样查询数据时会需要更多次磁盘I/O,查询性能不佳。
（2）B+树的用叶子节点存储数据，而且叶子节点用双向链表组织，因此范围查询很方便迅速，而红黑树要实现范围查询得走中序遍历，需要在树里跳来跳去，范围查询效率不如B+
### 为什么索引用 B+ 树，而不用 B 树?
（1）B+树只有叶子节点才存放索引和数据，而B树所有节点都会存放索引和数据，因此B+树可以比B树更矮胖，查询叶子节点的磁盘IO次数会更少（这是因为一般**一个节点通常对应一个页**（16KB数据），而b+的非叶子节点可以存更多的指针）
（2）B+便于范围查询，范围查询效率更高。B树需要中序遍历
（3 非重点）B+树增删查改效率更加稳定：B+ 树有大量的冗余节点，这些冗余数据可以让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化。另外，B+树把所有的用户记录都放到了叶子节点这一层，因此查询、插入、删除数据都需要走到最后一层，这不同于 B 树可能在任意一层找到数据，所以B+树更为稳定。
### 为什么索引用 B+ 树，而不用哈希表?
哈希表不支持范围查询和排序操作，也不支持联合索引最左匹配原则，如果重复键值多还容易造成哈希碰撞，而B+树则可以满足这些应用场景。
### 聚簇索引和非聚簇索引有什么区别?
聚簇索引和非聚簇索（二级索引）引最主要的区别是 B+树叶子节点存放的内容不同：
·聚簇索引的 B+树叶子节点存放的是主键值+完整的记录;
·非聚簇索引的 B+树叶子节点存放的是索引值+主键值;
如果查询语句的查询条件用了二级索引，但是查询的数据不是主键值,也不是二级索引值，这时在二级索引找到主键值后，就需要回表才能查找到数据，，需要扫描两次 B+树。如果查询的列是主键值和二级索引值时，因为只在二级索引就能查询到，这时候就会用到覆盖索引，不需要回表，只需要扫描一次 B+树。
## 索引应用
### MySQL 有哪些索引?
我了解到 MySQL 有主键索引I、唯一索引I、普通索引I、前缀索引I、联合索引这几种索引。Innodb 引擎会要求每一张数据库表都必须要有一个主键索引，比如表里的 id 字段就是主键索引l。
然后针对查询比较频繁的字段，我们可以对这个字段建立普通索引，如果是多个字段的话，可以考虑建立联合索引，利用索引覆盖的特性提高查询效率。对于长文本、字符串等类型的字段，比如文章标题、商品名称等，我们可以只对这些字段的前缀部分建立索引，也就是建立前缀索引，这样可以减少索引的存储空间。

- 具体如下：
（1）主键索引：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表上最多只有一个主键索引，不允许空值。
（2）普通索引：建立在普通字段上的索引
（3）唯一索引：建立在unique字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但允许有空值
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20) UNIQUE
);
```
举例如`email` 和 `phone` 都是唯一索引字段。那么表中不能有两行的 `email` 值相同，也不能有两行的 `phone` 值相同。根据 SQL 标准，**NULL ≠ NULL**，即两个 NULL 不被认为是“相等”的，所以说允许空值
（4）前缀索引：前缀索引是对字符类型的前几个字符建立的索引，而非整个字段，前缀可以建立在char、varchar、binary、varbinary列上，使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率
（5）联合索引：将多个字段组合成一个索引
### 为什么要建索引？
没有建立索引的时候查询数据，搜索时间复杂度是O（n），这样的查询效率比较低。
简历了索引后，索引列数据会按照顺序存储，这时候我们可以用类似二分搜索的方式去快速查数据，B+树索引是多叉树，搜索复杂是O（logdN），这样就提高了搜索速度。
除此之外还可以避免外部排序以及使用临时表的问题，以及将随机IO变成顺序IO
### 我们一般选择什么样的字段来建立索引?
可以对频繁用于**Where**查询条件的字段建立索引，如果查询条件不止一个字段，可以建立联合索引。
还有对于经常用于**排序**、**分组**的字段建立索引。这样在查询的时候就不需要再去做一次排序了，因为建立索引后B+树中的数据都是排序好的。
不过对于区分度不高的字段没必要建立索引。如果mysql的优化器发现某个值在表中出现的比例很高时 会忽略索引进行全表扫描，这样索引就没价值了。
### 索引越多越好吗？
不是的，索引虽然能提高查询效率，但是多建立一个索引，就意味着新生成1个 B+树索引，是需要**占用存储空间**的，特别是在表数据量非常大的时候，索引占用的空间越大。
还有，索引越多数据库的**写入性能会下降**，因为每次对表进行增删改操作的时候，都需要去维护各个 B+ 树索引的有序性。
### 索引怎么优化？
（1）对于只需要查询几个字段数据的sql来说，我们可以针对这些字段建立联合索引，这样查询方式就变成覆盖索引了，避免回表跟大量IO操作。
（2）主键索引应该是递增的值，索引是按照顺序存储数据的，如果主键的值是随机的值，可能会引发页分裂。页分裂会导致大量内存碎片，这样索引结构就不紧凑了，影响查询效率
（3）避免写出让索引失效的语句，比如对索引进行计算、函数、类型转换等。用联合索引要遵守最左匹配原则；
### ❌ 常见让索引失效的写法：

|写法|问题|是否能用索引|
|---|---|---|
|`WHERE YEAR(create_time) = 2023`|使用函数|❌ 否|
|`WHERE price + 10 > 100`|计算表达式|❌ 否|
|`WHERE phone = 13800000000`（phone 是字符串，但传入数字）|类型不匹配|❌ 否|
|`WHERE name LIKE '%abc'`|前缀模糊匹配|❌ 否|

### ✅ 正确写法（避免索引失效）：

| 写法                                                        | 优化说明        |
| --------------------------------------------------------- | ----------- |
| `WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31'` | 避免函数，保留字段原样 |
| `WHERE price > 90`                                        | 把计算移到右边     |
| `WHERE phone = '13800000000'`                             | 保持类型一致      |
| `WHERE name LIKE 'abc%'`                                  | 后缀模糊匹配可用索引  |
|                                                           |             |
（4）对于大字符串列可以考虑使用前缀索引
### 什么情况下会回表查询？
在使用二级索引进行查询的时候，如果查询的列，不能在二级索引中全部查询到，那么就会发生回表的过程，先通过二级索引的值查到聚簇索引值（即主键id），再通过聚簇索引的值定位行记录数据，需要扫描两次索引 B+树，它的性能较扫一遍索引树更低。
### 什么是覆盖索引？
当查询的数据是能在二级索引的叶子节点里查询到的话，这时就**不用再回主键索引查**了，那就不需要回到主键索引去查行记录了，这种不需要回表的过程，就叫覆盖索引I，这种查询方式效率会比较高，只需要查二级索引这一棵 B+ 树。
### 建立了索引，查询的时候一定会用到索引吗？
不是的，有两种情况不走
（1）对索引字段进行左模糊匹配，表达式计算、函数、隐式类型转换，这时候查询就不能走索引了，只能全表扫描。在对联合索引字段进行查询时，没有遵循最左匹配原则，也会发生索引失效
（2）优化器会基于成本考虑选择查询方式，在二级索引查询时，会计算回表和全表扫描的成本，如果回表的代价太高，优化器就不会走索引
### 什么是最左匹配原则？
假设有一个（a，b，c）联合索引l，它的存储顺序是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。 由于这个的特性，在使用联合索引时，存在最左匹配原则，具体的规则:
- MySQL 会从联合索引I从最左边的索引列开始匹配查询条件，然后依次从从左到右的顺序匹配，如果查询条件没有使用到某个列，那么该列右边的所有列都无法使用走索引。
- 当查询条件中使用了某个列，但是该列的值包含范围查询，范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。所以，我们在使用联合索引的时候，要遵守最左匹配原则，否则可能会出现部分索引字段走不了索引。
(在联合索引中，**第二个字段的排序是依赖于第一个字段的**。只有当第一个字段**相等**（值固定）时，第二个字段才是有序的；一旦第一个字段是**范围**（值不固定），第二个字段在全局看就是**乱序**的。)
### 联合索引 `(a,b,c)`，下面的查询语句会不会走索引？具体哪些字段能走？
  1. `select * from T where a=1 and b=2 and c=3;
  会，因此从左到右
  2. `select * from T where a=1 and b>2 and c=3;`
  
  3. `select * from T where c=1 and a=2 and b=3;

  4. `select * from T where a=2 and c=3;`

  5. `select * from T where b=2 and c=3;`

  6. `select (a,b) from T where a=1 and b>2;

  
### `where a>1 and b=2 and c<3` 怎么建立索引？

## 事务
### MySQL 事务有什么特性?
### 事务的隔离性如何保证?
### 事务的持久性如何保证？
### 事务的原子性如何保证？
### MySQL 事务隔离级别有哪些？分别解决哪些问题？
### 脏读和幻读有什么区别?
### MySQL 默认的隔离级别是什么？怎么实现的？
### 介绍一下 MVCC
### MVCC 如何判断行记录对某一个事务是否可见?
### 读已提交和可重复读隔离级别实现 MVCC 的区别?
### 可重复读解决了什么问题？有没有完全解决幻读?
### 可重复读为什么不能完全避免幻读？什么情况下出现幻读？

## 锁
### 详细说一下 MySQL 数据库中锁的分类
### 在线上修改表结构，会发生什么？
### InnoDB 存储引擎中的行级锁有哪些?
### 一条 `UPDATE` 语句没有带 `WHERE` 条件，加的是什么锁?
### MySQL 怎么实现乐观锁?
### 了解过 MySQL 死锁问题吗?
### MySQL 怎么避免死锁?

## 日志
### MySQL 有哪些日志？有什么区别?
### `redo log` 和 `binlog` 的区别和应用场景?
### `redo log` 是怎么实现持久化的?
### 为什么事务提交需要两阶段提交？
### 两阶段提交的过程是怎样的？

## 性能优化
### 怎么找到慢 SQL?
### 如何优化慢 SQL?
### 深分页场景如何优化？
### 如果 SQL 和索引都没问题，查询还是很慢怎么办?

## 高可用
### MySQL 主从复制的过程是怎么样?
### MySQL 提供了几种复制模式？默认的复制模式是什么?
### 什么是分库分表？什么时候需要分表？什么时候需要分库？
### 分库分表后，会产生什么问题？怎么解决？
