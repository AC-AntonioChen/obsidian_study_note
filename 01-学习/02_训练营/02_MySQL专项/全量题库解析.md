以下是将 OCR 扫描文本还原、清洗水印干扰字符并整理为 Markdown 格式后的内容：

## SQL 语法

### 1. count(主键) 和 count(非主键) 结果会不同吗?

**分析：**

`count()` 函数是返回表中某个列的非 NULL 值的数量。

*   **count(主键)：** 由于主键的列不能存 NULL 值，所以 count(主键) 返回的结果，可以表示数据库表中所有行数据的数量。
*   **count(非主键)：** 由于非主键的列可以存 NULL 值，那么 count(非主键) 返回表中非主键列的非 NULL 值的数量。

**回答：**

主键是不能存 NULL 值的，所以 count 主键代表统计表中所有行数据的数量。
而非主键是可以存 NULL 值的，所以 Count 非主键统计的是表中这个列的非 NULL 值的数量。

**推荐学习：** `count(*)` 和 `count(1)` 有什么区别？哪个性能最好?

---

### 2. MySQL 内连接、外连接有什么区别?

**分析：**

*   **内连接（INNER JOIN）：** 内连接返回两个表中匹配的行，即只返回两个表中共有的数据。
*   **外连接（OUTER JOIN）：** 外连接则返回两个表中匹配和不匹配的行。MySQL 外连接主要有左外连接（LEFT JOIN）、右外连接（RIGHT JOIN）两种。
    *   **左连接（LEFT JOIN）：** `SELECT * FROM A LEFT JOIN B ON A.A_id = B.B_id`，将返回左表 A 中的所有行和右表 B 中与之匹配的行。如果 B 表中没有匹配的行，则 B 表相关的列使用 NULL 值填充。
    *   **右连接（RIGHT JOIN）：** `SELECT * FROM A RIGHT JOIN B ON A.A_id = B.B_id`，将返回右表 B 中的所有行和左表 A 中与之匹配的行。如果 A 表中没有匹配的行，则 A 表相关的列使用 NULL 值填充。

**回答：**

内连接和外连接都是用于连表查询。
*   **内连接**是只返回两个表匹配的数据行。
*   **外连接**可以返回两个表匹配和不匹配的数据行，外连接主要分为左连接和右连接。
    *   左连接返回左表中的所有行和右表中匹配的行，如果右表中没有匹配的行，则用 NULL 值填充。
    *   右连接返回右表中的所有行和左表中匹配的行，如果左表中没有匹配的行，则用 NULL 值填充。

---

### 3. 外连接时 ON 和 WHERE 过滤条件区别?

**分析：**

*   **内连接：** 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。在内连接中，`WHERE` 子句和 `ON` 子句是等价的。
*   **外连接：**
    *   **WHERE 子句：** 不论是内连接还是外连接，凡是不符合 WHERE 子句中过滤条件的记录都不会被加入最后的结果集。它是在连接操作之后执行的进一步筛选。
    *   **ON 子句：** 专门为外连接设计的。驱动表中的记录即使在被驱动表中没有匹配的记录（即 ON 条件不满足），也仍然需要加入到结果集（对应的被驱动表字段填充 NULL）。ON 中的过滤条件在连接时进行。

**回答：**

在外连接中，使用 ON 和 WHERE 过滤条件的区别在于：
*   **ON** 中的过滤条件在连接时进行，用于决定是否匹配被驱动表的数据，即使不匹配，驱动表的行也会保留。
*   **WHERE** 用于指定过滤条件，对连接后的结果集进行进一步筛选，凡是不满足 WHERE 条件的都会被过滤掉。

---

### 4. HAVING 与 WHERE 的区别?

**分析：**

*   **WHERE** 子句在 `GROUP BY` 分组和聚合函数之前对数据行进行过滤，WHERE 子句无法使用聚合函数。
*   **HAVING** 子句对 `GROUP BY` 分组和聚合函数之后的数据行进行过滤，HAVING 子句可以使用聚合函数。

**回答：**

在 GROUP BY 分组查询过程中：
*   **WHERE** 是工作在 GROUP BY 之前，是对分组之前的数据进行筛选，无法使用聚合函数。
*   **HAVING** 是工作在 GROUP BY 之后，主要对分组之后的数据进行筛选，可以使用聚合函数。

---

### 5. IN 和 EXISTS 的区别?

**代码块：**
```sql
-- 使用 IN
select * from A where id in (select id from B);

-- 使用 EXISTS
select * from A where exists (select 1 from B where A.id=B.id);
```

**性能区别分析：**

*   **IN：** 当 B 表数据较大时不适合使用 `IN()`，因为它会把 B 表数据全部遍历一次（类似于 `for(A) { for(B) }`）。如果 A 表是小表，B 表是大表，效率很差。
*   **EXISTS：** 适合 B 表比 A 表大的情况。
*   **总结：** 当 A 表（外表）与 B 表（内表）数据一样大时，IN 与 EXISTS 效率差不多，可选一个使用。当 B 表数据较大时，EXISTS 效率优于 IN。

---

### 6. 数据库常见约束有哪些?

**分析：**

*   **唯一性约束 (Unique)：** 保证字段在表中的数值是唯一的，如果插入相同字段值的记录，就会报唯一性约束的错误。
*   **非空约束 (Not Null)：** 保证字段不能为 NULL。
*   **默认约束 (Default)：** 给字段设置默认值，如果插入数据的时候，这个字段没有取值的话，就会用默认值。

---

### 7. DELETE、DROP、TRUNCATE 有什么区别?

**分析：**

| 区别点 | DROP | TRUNCATE | DELETE |
| :--- | :--- | :--- | :--- |
| **执行速度** | 快 | 较快 | 慢 |
| **命令分类** | DDL (数据定义语言) | DDL (数据定义语言) | DML (数据操作语言) |
| **回滚** | 不可回滚 | 不可回滚 | 可回滚 |
| **自增初始值** | 重置 | 重置 | 不重置 |
| **空间释放** | 释放表空间 | 释放表空间 (保留结构) | 不释放 (仅标记) |

**回答：**

1.  **DELETE：** 是删除表中的数据，可以选择删除部分或全部。DELETE 删除的数据是可以回滚的。它是给数据打上删除标记，目的是为了空间复用，磁盘文件大小不会缩减。
2.  **DROP：** 是删除表结构和表中所有的数据，立刻释放磁盘空间。
3.  **TRUNCATE：** 是只删除表中所有的记录（数据清空），表结构保持不变，重置 ID。
4.  **性能排序：** `DROP > TRUNCATE > DELETE`。

---

### 8. 联合查询中 UNION 和 UNION ALL 的区别是什么?

**分析：**

*   **UNION：** 用于合并多个查询结果，并**去除重复**的行。查询结果中的重复行只会被包含一次。
*   **UNION ALL：** 也用于合并多个查询结果，但**不会去除重复**的行。

**回答：**

*   **UNION：** 在合并结果集后会自动剔除重复的行。
*   **UNION ALL：** 则会保留所有的重复行，不会进行去重操作，因此效率通常比 UNION 高。

---

### 9. 数据库范式与反范式

**分析：**

*   **范式化 (Normalization)：** 旨在消除数据冗余，避免更新异常、插入异常，保证数据的一致性和完整性。通常会将数据分解为多个表。
*   **反范式化：** 在实际应用中，范式化导致查询需要进行大量的表连接操作，成本很高。因此有时会进行反范式设计，通过字段冗余来避免联表查询，提高读取性能。

**回答：**

范式化将数据分解为多个表，那么查询数据的时候，就需要进行更多的表连接操作。在应用中，进行表关联的成本是很高，也不适合分库分表的场景。所以有时候实际应用设计表的时候会**反范式**，比如说可以通过字段冗余的设计，避免联表查询。

---

### 10. count(*) 性能比 count(1) 好吗?

**分析：**

按照性能排序：`count(*) = count(1) > count(主键字段) > count(字段)`

MySQL 会将 `count(*)` 参数转化为参数 0 来处理（`count(0)`），所以在执行过程中，`count(*)` 和 `count(1)` 的执行过程基本是一样的，性能没有什么差异。

**回答：**

不是的。MySQL 会将星号参数转化为参数 0 来处理，所以 `count(*)` 和 `count(1)` 性能是一样的。

---

### 11. 说一说执行一条查询 SQL 语句的全过程

**分析：**

MySQL 整体架构流程：
1.  **连接器：** 建立连接、校验身份。
2.  **查询缓存：** (MySQL 8.0 已删除) 查找缓存，命中则直接返回。
3.  **解析器：** 词法分析、语法分析，构建语法树。
4.  **优化器：** 计算查询成本，选择索引，生成执行计划。
5.  **执行器：** 根据执行计划调用存储引擎接口。
6.  **存储引擎：** 读取记录返回给执行器。

**回答：**

MySQL 执行一条查询 SQL 语句的时候，会经过连接器、查询缓存、解析器、优化器、执行器、存储引擎这些模块。

1.  首先 MySQL 的**连接器**会负责建立连接、校验用户身份。
2.  第二步，**查询缓存**（8.0版本已删），如果命中直接返回。
3.  第三步，**解析器**对 SQL 进行词法和语法分析，构建语法树。
4.  第四步，**优化器**基于查询成本选择最小的执行计划（如选择索引）。
5.  第五步，**执行器**根据执行计划从**存储引擎**读取记录，返回给客户端。

## 存储引擎

### 12. MySQL 存储引擎有哪些?

**分析：**

MySQL 整体分为 Server 层和存储引擎层。常见的引擎有 InnoDB, MyISAM, Memory, Archive, CSV 等。

**回答：**

MySQL 常见的存储引擎有 InnoDB、MyISAM、Memory。
*   **InnoDB：** 是 MySQL 默认的存储引擎，支持事务和行级锁，具有崩溃恢复功能。
*   **MyISAM：** 不支持事务和行级锁（只支持表锁），适合读多写少的场景。
*   **Memory：** 数据存储在内存中，读写快，但数据不具备持久性（断电丢失），适合临时存储。

---

### 13. MyISAM 和 InnoDB 存储引擎有什么区别?

**分析：**

| 特性 | InnoDB | MyISAM |
| :--- | :--- | :--- |
| **事务** | 支持 | 不支持 |
| **锁** | 支持行锁和表锁 | 仅支持表锁 |
| **外键** | 支持 | 不支持 |
| **恢复性** | 支持 (Redo Log) | 无事务日志 |
| **表结构** | 索引组织表 (数据即索引) | 堆表 (数据索引分离) |
| **索引叶节点** | 存储完整数据 | 存储数据地址 |

**回答：**

1.  **数据存储：** InnoDB 采用索引组织表（聚簇索引），数据和索引存在同一个文件；MyISAM 采用堆表，数据和索引分开存储。
2.  **锁粒度：** InnoDB 支持行级锁，并发性能好；MyISAM 只支持表锁。
3.  **事务：** InnoDB 支持事务（ACID），MyISAM 不支持。
4.  **查询性能：** InnoDB 利用聚簇索引主键查询极快；MyISAM 记录插入顺序存储，更新索引需更新地址。

---

### 14. MySQL 为什么选择 InnoDB 作为默认引擎?

**回答：**

InnoDB 引擎在事务支持、并发性能、崩溃恢复等方面具有优势：
*   **事务支持：** 支持 ACID 特性，而 MyISAM 不支持。
*   **并发性能：** 采用行级锁，相比 MyISAM 的表锁，锁粒度更小，并发高。
*   **崩溃恢复：** 通过 Redo Log 实现崩溃恢复，保证数据持久性。

---

### 16. NULL 值是如何存储的?

**分析：**

MySQL 行格式中包含一个“NULL 值列表”。
*   如果存在允许 NULL 值的列，则每个列对应一个二进制位 (bit)。
*   二进制位为 1 代表该列为 NULL，为 0 代表不为 NULL。
*   这个列表逆序排列。

**回答：**

MySQL 行格式中会用**「NULL 值列表」**来标记值为 NULL 的列。每个列对应一个二进制位，如果列的值为 NULL，就会标记二进制位为 1，否则为 0。所以 NULL 值并不会存储在行格式中的真实数据部分，而是存储在行头信息的 NULL 值列表中，至少占用 1 字节空间。

---

### 17. CHAR 和 VARCHAR 有什么区别？哪个性能更好?

**分析：**

*   **CHAR：** 固定长度。不管实际存多少，都占定义长度（不足补空格）。
*   **VARCHAR：** 可变长度。占用实际长度 + 额外长度标识（1-2字节）。
*   **性能：** 理论上 CHAR 略快（CPU 指令少），但 VARCHAR 节省空间，减少磁盘 I/O。当 Buffer Pool 足够大时，差别不大；当 I/O 是瓶颈时，VARCHAR 可能更好。

**回答：**

*   **CHAR** 是固定长度，不足会自动填充空格。
*   **VARCHAR** 是可变长度，只占用实际长度 + 长度前缀。
*   **性能：** 站在 CPU 角度，CHAR 更快（定长好计算）；站在磁盘 I/O 角度，VARCHAR 更短，I/O 效率可能更高。总体来看，在内存充足时差别不大。

---

### 18. 假如说一个字段是 varchar(10)，但它其实只有 6 个字节，那他在内存中占的存储空间是多少？在文件中占的存储空间是多少?

**回答：**

*   **文件存储：** 会占用 6 字节数据 + 1 字节长度标识（共 7 字节）。
*   **内存占用：** MySQL 内存引擎通常会分配固定大小的内存块（基于最大定义长度）来保存内部值，所以内存中可能会按 `varchar(10)` 的最大定义来分配，以避免碎片和频繁重分配。

---

### 19. 如果硬件内存特别大，MySQL 缓存能否替代 Redis?

**分析：**

MySQL 是面向磁盘设计的（Buffer Pool, Undo/Redo Log, 锁机制），首要目标是减少 I/O。Redis 是面向内存设计的（O(1) 访问，无复杂事务锁开销）。

**回答：**

**不能。**
即使 Buffer Pool 无限大，MySQL 的性能依然不如 Redis：
1.  MySQL 查询需要走 B+ 树搜索（O(logN)），Redis Hash 查找是 O(1)。
2.  MySQL 为了事务隔离性有复杂的加锁机制，Redis 单线程（核心模型）无此开销。
3.  MySQL 有 WAL（写前日志）刷盘机制。

## 索引结构

### 20. MySQL 有哪些索引类型?

**回答：**

MySQL 主要支持：
*   **B+ 树索引：** InnoDB 默认，支持排序、分组、范围查询。
*   **Hash 索引：** Memory 引擎支持，仅支持精确匹配，不支持范围。
*   **全文索引 (Full-text)：** 用于文本搜索。

---

### 22. B+ 树的特性是什么?

**回答：**

B+ 树是一个多叉平衡查找树，主要特性有：
1.  **非叶子节点不存数据：** 只存储索引（路由信息），让树更扁平，一次 I/O 读入更多索引。
2.  **所有数据都在叶子节点：** 数据存储在叶子节点，且按顺序存放。
3.  **双向链表：** 所有叶子节点通过双向指针串联，方便范围查询和全表扫描。

---

### 23. B+ 树和 B 树有什么区别?

**回答：**

1.  **数据位置：** B 树所有节点都存储索引+数据；B+ 树只有叶子节点存数据，非叶子节点只存索引。这使得 B+ 树更“矮胖”，磁盘 I/O 次数更少。
2.  **范围查询：** B+ 树叶子节点由链表连接，范围查询只需遍历链表；B 树需要中序遍历，效率较低。
3.  **稳定性：** B+ 树每次查询都要走到叶子节点，查询耗时稳定。

---

### 24. MySQL 为什么使用 B+ 树?

**回答：**

1.  **磁盘读写代价低：** 非叶子节点不存数据，节点能容纳更多索引，树更矮，减少 I/O。
2.  **便于范围查询：** 叶子节点的双向链表天然支持范围查询（Range Scan）。
3.  **性能稳定：** 所有查询都必须到达叶子节点。

---

### 27. 为什么索引用 B+ 树？而不用哈希表?

**回答：**

*   **哈希表 (Hash)：** 虽然单条查询快 (O(1))，但是数据是散列分布的，无序。**无法进行范围查询、排序、模糊查询**。
*   **B+ 树：** 有序结构，完美支持范围查询和排序，且磁盘读写效率高。

---

### 29. 聚簇索引和非聚簇索引有什么区别?

**分析：**

*   **聚簇索引 (Clustered Index)：** 叶子节点存储「主键值 + 完整的行记录」。(InnoDB 主键索引)
*   **非聚簇索引 (Secondary Index)：** 叶子节点存储「索引列值 + 主键值」。

**回答：**

最主要区别是 **B+ 树叶子节点存放的内容不同**：
*   **聚簇索引：** 存放主键值和完整记录。
*   **非聚簇索引（二级索引）：** 存放索引值和主键值。
*   **查询差异：** 如果查二级索引且需要获取完整数据，需要先拿到主键，再回表到聚簇索引查数据（回表）。

---

### 30. 什么是覆盖索引?

**回答：**

当查询的列（SELECT ...）能够在二级索引的叶子节点中全部找到（例如查主键或索引本身的列），就**不需要回到主键索引（聚簇索引）去查行记录了**。这种不需要“回表”的过程，就叫覆盖索引，效率极高。

---

### 31. 什么情况下会回表?

**回答：**

在使用二级索引查询时，如果查询的列不能在二级索引中全部找到（例如 `SELECT *`），MySQL 只能先通过二级索引找到对应的主键 ID，然后再拿着这个 ID 去聚簇索引（主键索引）中查找完整的行记录。这个过程叫“回表”，需要扫描两棵 B+ 树。

---

### 32. Insert 操作对 B+ 树结构的改变 (页分裂)?

**回答：**

*   **自增主键：** 顺序插入，数据追加在当前页尾部，页满开辟新页，效率高。
*   **随机主键 (如 UUID)：** 插入值随机，可能插入到已有数据页的中间。如果该页已满，需要将数据移动、分割成两个页（**页分裂**）。
*   **后果：** 页分裂导致大量的内存碎片，索引结构不紧凑，增加随机 I/O，严重影响性能。

---

### 33. 假如一张表有两千万数据，B+ 树高度是多少?

**回答：**

具体取决于字段大小。假设一行记录 1KB，主键 ID 为 BigInt。
一般情况下，MySQL InnoDB 的 B+ 树高度通常是 **3 层**。
*   这得益于非叶子节点只存索引，一个节点（16KB）能存上千个指针，3 层结构足以支撑两千万级别的数据。

---

### 37. 主键是用自增还是 UUID?

**回答：**

推荐用 **自增 ID**。
1.  **性能：** 既然 B+ 树是有序的，自增 ID 保证顺序插入，避免页分裂，减少随机 I/O。
2.  **存储：** BigInt (8字节) 比 UUID (36字节字符串) 占用空间小得多，能让 B+ 树节点容纳更多索引，降低树高。
3.  **场景：** 在分库分表场景下，自增 ID 无法保证全局唯一，此时可使用 **雪花算法 (Snowflake)** 生成的 ID（也就是有序的大整数），尽量避免使用随机 UUID。

---

### 38. 普通索引和唯一索引有什么区别？哪个更新性能更好?

*(注：原文本此处截断，仅列出问题)*