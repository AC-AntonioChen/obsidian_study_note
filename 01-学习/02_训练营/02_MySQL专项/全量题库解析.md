
## SQL 语法

### 1. count(主键) 和 count(非主键) 结果会不同吗?

**分析：**

`count()` 函数是返回表中某个列的非 NULL 值的数量。

*   **count(主键)：** 由于主键的列不能存 NULL 值，所以 count(主键) 返回的结果，可以表示数据库表中所有行数据的数量。
*   **count(非主键)：** 由于非主键的列可以存 NULL 值，那么 count(非主键) 返回表中非主键列的非 NULL 值的数量。

**回答：**

主键是不能存 NULL 值的，所以 count 主键代表统计表中所有行数据的数量。
而非主键是可以存 NULL 值的，所以 Count 非主键统计的是表中这个列的非 NULL 值的数量。

**推荐学习：** `count(*)` 和 `count(1)` 有什么区别？哪个性能最好?

---

### 2. MySQL 内连接、外连接有什么区别?

**分析：**

*   **内连接（INNER JOIN）：** 内连接返回两个表中匹配的行，即只返回两个表中共有的数据。
*   **外连接（OUTER JOIN）：** 外连接则返回两个表中匹配和不匹配的行。MySQL 外连接主要有左外连接（LEFT JOIN）、右外连接（RIGHT JOIN）两种。
    *   **左连接（LEFT JOIN）：** `SELECT * FROM A LEFT JOIN B ON A.A_id = B.B_id`，将返回左表 A 中的所有行和右表 B 中与之匹配的行。如果 B 表中没有匹配的行，则 B 表相关的列使用 NULL 值填充。
    *   **右连接（RIGHT JOIN）：** `SELECT * FROM A RIGHT JOIN B ON A.A_id = B.B_id`，将返回右表 B 中的所有行和左表 A 中与之匹配的行。如果 A 表中没有匹配的行，则 A 表相关的列使用 NULL 值填充。

**回答：**

内连接和外连接都是用于连表查询。
*   **内连接**是只返回两个表匹配的数据行。
*   **外连接**可以返回两个表匹配和不匹配的数据行，外连接主要分为左连接和右连接。
    *   左连接返回左表中的所有行和右表中匹配的行，如果右表中没有匹配的行，则用 NULL 值填充。
    *   右连接返回右表中的所有行和左表中匹配的行，如果左表中没有匹配的行，则用 NULL 值填充。

---

### 3. 外连接时 ON 和 WHERE 过滤条件区别?

**分析：**

*   **内连接：** 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。在内连接中，`WHERE` 子句和 `ON` 子句是等价的。
*   **外连接：**
    *   **WHERE 子句：** 不论是内连接还是外连接，凡是不符合 WHERE 子句中过滤条件的记录都不会被加入最后的结果集。它是在连接操作之后执行的进一步筛选。
    *   **ON 子句：** 专门为外连接设计的。驱动表中的记录即使在被驱动表中没有匹配的记录（即 ON 条件不满足），也仍然需要加入到结果集（对应的被驱动表字段填充 NULL）。ON 中的过滤条件在连接时进行。

**回答：**

在外连接中，使用 ON 和 WHERE 过滤条件的区别在于：
*   **ON** 中的过滤条件在连接时进行，用于决定是否匹配被驱动表的数据，即使不匹配，驱动表的行也会保留。
*   **WHERE** 用于指定过滤条件，对连接后的结果集进行进一步筛选，凡是不满足 WHERE 条件的都会被过滤掉。

---

### 4. HAVING 与 WHERE 的区别?

**分析：**

*   **WHERE** 子句在 `GROUP BY` 分组和聚合函数之前对数据行进行过滤，WHERE 子句无法使用聚合函数。
*   **HAVING** 子句对 `GROUP BY` 分组和聚合函数之后的数据行进行过滤，HAVING 子句可以使用聚合函数。

**回答：**

在 GROUP BY 分组查询过程中：
*   **WHERE** 是工作在 GROUP BY 之前，是对分组之前的数据进行筛选，无法使用聚合函数。
*   **HAVING** 是工作在 GROUP BY 之后，主要对分组之后的数据进行筛选，可以使用聚合函数。

---

### 5. IN 和 EXISTS 的区别?

**代码块：**
```sql
-- 使用 IN
select * from A where id in (select id from B);

-- 使用 EXISTS
select * from A where exists (select 1 from B where A.id=B.id);
```

**性能区别分析：**

*   **IN：** 当 B 表数据较大时不适合使用 `IN()`，因为它会把 B 表数据全部遍历一次（类似于 `for(A) { for(B) }`）。如果 A 表是小表，B 表是大表，效率很差。
*   **EXISTS：** 适合 B 表比 A 表大的情况。
*   **总结：** 当 A 表（外表）与 B 表（内表）数据一样大时，IN 与 EXISTS 效率差不多，可选一个使用。当 B 表数据较大时，EXISTS 效率优于 IN。

---

### 6. 数据库常见约束有哪些?

**分析：**

*   **唯一性约束 (Unique)：** 保证字段在表中的数值是唯一的，如果插入相同字段值的记录，就会报唯一性约束的错误。
*   **非空约束 (Not Null)：** 保证字段不能为 NULL。
*   **默认约束 (Default)：** 给字段设置默认值，如果插入数据的时候，这个字段没有取值的话，就会用默认值。

---

### 7. DELETE、DROP、TRUNCATE 有什么区别?

**分析：**

| 区别点 | DROP | TRUNCATE | DELETE |
| :--- | :--- | :--- | :--- |
| **执行速度** | 快 | 较快 | 慢 |
| **命令分类** | DDL (数据定义语言) | DDL (数据定义语言) | DML (数据操作语言) |
| **回滚** | 不可回滚 | 不可回滚 | 可回滚 |
| **自增初始值** | 重置 | 重置 | 不重置 |
| **空间释放** | 释放表空间 | 释放表空间 (保留结构) | 不释放 (仅标记) |

**回答：**

1.  **DELETE：** 是删除表中的数据，可以选择删除部分或全部。DELETE 删除的数据是可以回滚的。它是给数据打上删除标记，目的是为了空间复用，磁盘文件大小不会缩减。
2.  **DROP：** 是删除表结构和表中所有的数据，立刻释放磁盘空间。
3.  **TRUNCATE：** 是只删除表中所有的记录（数据清空），表结构保持不变，重置 ID。
4.  **性能排序：** `DROP > TRUNCATE > DELETE`。

---

### 8. 联合查询中 UNION 和 UNION ALL 的区别是什么?

**分析：**

*   **UNION：** 用于合并多个查询结果，并**去除重复**的行。查询结果中的重复行只会被包含一次。
*   **UNION ALL：** 也用于合并多个查询结果，但**不会去除重复**的行。

**回答：**

*   **UNION：** 在合并结果集后会自动剔除重复的行。
*   **UNION ALL：** 则会保留所有的重复行，不会进行去重操作，因此效率通常比 UNION 高。

---

### 9. 数据库范式与反范式

**分析：**

*   **范式化 (Normalization)：** 旨在消除数据冗余，避免更新异常、插入异常，保证数据的一致性和完整性。通常会将数据分解为多个表。
*   **反范式化：** 在实际应用中，范式化导致查询需要进行大量的表连接操作，成本很高。因此有时会进行反范式设计，通过字段冗余来避免联表查询，提高读取性能。

**回答：**

范式化将数据分解为多个表，那么查询数据的时候，就需要进行更多的表连接操作。在应用中，进行表关联的成本是很高，也不适合分库分表的场景。所以有时候实际应用设计表的时候会**反范式**，比如说可以通过字段冗余的设计，避免联表查询。

---

### 10. count(*) 性能比 count(1) 好吗?

**分析：**

按照性能排序：`count(*) = count(1) > count(主键字段) > count(字段)`

MySQL 会将 `count(*)` 参数转化为参数 0 来处理（`count(0)`），所以在执行过程中，`count(*)` 和 `count(1)` 的执行过程基本是一样的，性能没有什么差异。

**回答：**

不是的。MySQL 会将星号参数转化为参数 0 来处理，所以 `count(*)` 和 `count(1)` 性能是一样的。

---

### 11. 说一说执行一条查询 SQL 语句的全过程

**分析：**

MySQL 整体架构流程：
1.  **连接器：** 建立连接、校验身份。
2.  **查询缓存：** (MySQL 8.0 已删除) 查找缓存，命中则直接返回。
3.  **解析器：** 词法分析、语法分析，构建语法树。
4.  **优化器：** 计算查询成本，选择索引，生成执行计划。
5.  **执行器：** 根据执行计划调用存储引擎接口。
6.  **存储引擎：** 读取记录返回给执行器。

**回答：**

MySQL 执行一条查询 SQL 语句的时候，会经过连接器、查询缓存、解析器、优化器、执行器、存储引擎这些模块。

1.  首先 MySQL 的**连接器**会负责建立连接、校验用户身份。
2.  第二步，**查询缓存**（8.0版本已删），如果命中直接返回。
3.  第三步，**解析器**对 SQL 进行词法和语法分析，构建语法树。
4.  第四步，**优化器**基于查询成本选择最小的执行计划（如选择索引）。
5.  第五步，**执行器**根据执行计划从**存储引擎**读取记录，返回给客户端。

## 存储引擎

### 12. MySQL 存储引擎有哪些?

**分析：**

MySQL 整体分为 Server 层和存储引擎层。常见的引擎有 InnoDB, MyISAM, Memory, Archive, CSV 等。

**回答：**

MySQL 常见的存储引擎有 InnoDB、MyISAM、Memory。
*   **InnoDB：** 是 MySQL 默认的存储引擎，支持事务和行级锁，具有崩溃恢复功能。
*   **MyISAM：** 不支持事务和行级锁（只支持表锁），适合读多写少的场景。
*   **Memory：** 数据存储在内存中，读写快，但数据不具备持久性（断电丢失），适合临时存储。

---

### 13. MyISAM 和 InnoDB 存储引擎有什么区别?

**分析：**

| 特性 | InnoDB | MyISAM |
| :--- | :--- | :--- |
| **事务** | 支持 | 不支持 |
| **锁** | 支持行锁和表锁 | 仅支持表锁 |
| **外键** | 支持 | 不支持 |
| **恢复性** | 支持 (Redo Log) | 无事务日志 |
| **表结构** | 索引组织表 (数据即索引) | 堆表 (数据索引分离) |
| **索引叶节点** | 存储完整数据 | 存储数据地址 |

**回答：**

1.  **数据存储：** InnoDB 采用索引组织表（聚簇索引），数据和索引存在同一个文件；MyISAM 采用堆表，数据和索引分开存储。
2.  **锁粒度：** InnoDB 支持行级锁，并发性能好；MyISAM 只支持表锁。
3.  **事务：** InnoDB 支持事务（ACID），MyISAM 不支持。
4.  **查询性能：** InnoDB 利用聚簇索引主键查询极快；MyISAM 记录插入顺序存储，更新索引需更新地址。

---

### 14. MySQL 为什么选择 InnoDB 作为默认引擎?

**回答：**

InnoDB 引擎在事务支持、并发性能、崩溃恢复等方面具有优势：
*   **事务支持：** 支持 ACID 特性，而 MyISAM 不支持。
*   **并发性能：** 采用行级锁，相比 MyISAM 的表锁，锁粒度更小，并发高。
*   **崩溃恢复：** 通过 Redo Log 实现崩溃恢复，保证数据持久性。

---

### 16. NULL 值是如何存储的?

**分析：**

MySQL 行格式中包含一个“NULL 值列表”。
*   如果存在允许 NULL 值的列，则每个列对应一个二进制位 (bit)。
*   二进制位为 1 代表该列为 NULL，为 0 代表不为 NULL。
*   这个列表逆序排列。

**回答：**

MySQL 行格式中会用**「NULL 值列表」**来标记值为 NULL 的列。每个列对应一个二进制位，如果列的值为 NULL，就会标记二进制位为 1，否则为 0。所以 NULL 值并不会存储在行格式中的真实数据部分，而是存储在行头信息的 NULL 值列表中，至少占用 1 字节空间。

---

### 17. CHAR 和 VARCHAR 有什么区别？哪个性能更好?

**分析：**

*   **CHAR：** 固定长度。不管实际存多少，都占定义长度（不足补空格）。
*   **VARCHAR：** 可变长度。占用实际长度 + 额外长度标识（1-2字节）。
*   **性能：** 理论上 CHAR 略快（CPU 指令少），但 VARCHAR 节省空间，减少磁盘 I/O。当 Buffer Pool 足够大时，差别不大；当 I/O 是瓶颈时，VARCHAR 可能更好。

**回答：**

*   **CHAR** 是固定长度，不足会自动填充空格。
*   **VARCHAR** 是可变长度，只占用实际长度 + 长度前缀。
*   **性能：** 站在 CPU 角度，CHAR 更快（定长好计算）；站在磁盘 I/O 角度，VARCHAR 更短，I/O 效率可能更高。总体来看，在内存充足时差别不大。

---

### 18. 假如说一个字段是 varchar(10)，但它其实只有 6 个字节，那他在内存中占的存储空间是多少？在文件中占的存储空间是多少?

**回答：**

*   **文件存储：** 会占用 6 字节数据 + 1 字节长度标识（共 7 字节）。
*   **内存占用：** MySQL 内存引擎通常会分配固定大小的内存块（基于最大定义长度）来保存内部值，所以内存中可能会按 `varchar(10)` 的最大定义来分配，以避免碎片和频繁重分配。

---

### 19. 如果硬件内存特别大，MySQL 缓存能否替代 Redis?

**分析：**

MySQL 是面向磁盘设计的（Buffer Pool, Undo/Redo Log, 锁机制），首要目标是减少 I/O。Redis 是面向内存设计的（O(1) 访问，无复杂事务锁开销）。

**回答：**

**不能。**
即使 Buffer Pool 无限大，MySQL 的性能依然不如 Redis：
1.  MySQL 查询需要走 B+ 树搜索（O(logN)），Redis Hash 查找是 O(1)。
2.  MySQL 为了事务隔离性有复杂的加锁机制，Redis 单线程（核心模型）无此开销。
3.  MySQL 有 WAL（写前日志）刷盘机制。

## 索引结构

### 20. MySQL 有哪些索引类型?

**回答：**

MySQL 主要支持：
*   **B+ 树索引：** InnoDB 默认，支持排序、分组、范围查询。
*   **Hash 索引：** Memory 引擎支持，仅支持精确匹配，不支持范围。
*   **全文索引 (Full-text)：** 用于文本搜索。

---

### 22. B+ 树的特性是什么?

**回答：**

B+ 树是一个多叉平衡查找树，主要特性有：
1.  **非叶子节点不存数据：** 只存储索引（路由信息），让树更扁平，一次 I/O 读入更多索引。
2.  **所有数据都在叶子节点：** 数据存储在叶子节点，且按顺序存放。
3.  **双向链表：** 所有叶子节点通过双向指针串联，方便范围查询和全表扫描。

---

### 23. B+ 树和 B 树有什么区别?

**回答：**

1.  **数据位置：** B 树所有节点都存储索引+数据；B+ 树只有叶子节点存数据，非叶子节点只存索引。这使得 B+ 树更“矮胖”，磁盘 I/O 次数更少。
2.  **范围查询：** B+ 树叶子节点由链表连接，范围查询只需遍历链表；B 树需要中序遍历，效率较低。
3.  **稳定性：** B+ 树每次查询都要走到叶子节点，查询耗时稳定。

---

### 24. MySQL 为什么使用 B+ 树?

**回答：**

1.  **磁盘读写代价低：** 非叶子节点不存数据，节点能容纳更多索引，树更矮，减少 I/O。
2.  **便于范围查询：** 叶子节点的双向链表天然支持范围查询（Range Scan）。
3.  **性能稳定：** 所有查询都必须到达叶子节点。

---

### 27. 为什么索引用 B+ 树？而不用哈希表?

**回答：**

*   **哈希表 (Hash)：** 虽然单条查询快 (O(1))，但是数据是散列分布的，无序。**无法进行范围查询、排序、模糊查询**。
*   **B+ 树：** 有序结构，完美支持范围查询和排序，且磁盘读写效率高。

---

### 29. 聚簇索引和非聚簇索引有什么区别?

**分析：**

*   **聚簇索引 (Clustered Index)：** 叶子节点存储「主键值 + 完整的行记录」。(InnoDB 主键索引)
*   **非聚簇索引 (Secondary Index)：** 叶子节点存储「索引列值 + 主键值」。

**回答：**

最主要区别是 **B+ 树叶子节点存放的内容不同**：
*   **聚簇索引：** 存放主键值和完整记录。
*   **非聚簇索引（二级索引）：** 存放索引值和主键值。
*   **查询差异：** 如果查二级索引且需要获取完整数据，需要先拿到主键，再回表到聚簇索引查数据（回表）。

---

### 30. 什么是覆盖索引?

**回答：**

当查询的列（SELECT ...）能够在二级索引的叶子节点中全部找到（例如查主键或索引本身的列），就**不需要回到主键索引（聚簇索引）去查行记录了**。这种不需要“回表”的过程，就叫覆盖索引，效率极高。

---

### 31. 什么情况下会回表?

**回答：**

在使用二级索引查询时，如果查询的列不能在二级索引中全部找到（例如 `SELECT *`），MySQL 只能先通过二级索引找到对应的主键 ID，然后再拿着这个 ID 去聚簇索引（主键索引）中查找完整的行记录。这个过程叫“回表”，需要扫描两棵 B+ 树。

---

### 32. Insert 操作对 B+ 树结构的改变 (页分裂)?

**回答：**

*   **自增主键：** 顺序插入，数据追加在当前页尾部，页满开辟新页，效率高。
*   **随机主键 (如 UUID)：** 插入值随机，可能插入到已有数据页的中间。如果该页已满，需要将数据移动、分割成两个页（**页分裂**）。
*   **后果：** 页分裂导致大量的内存碎片，索引结构不紧凑，增加随机 I/O，严重影响性能。

---

### 33. 假如一张表有两千万数据，B+ 树高度是多少?

**回答：**

具体取决于字段大小。假设一行记录 1KB，主键 ID 为 BigInt。
一般情况下，MySQL InnoDB 的 B+ 树高度通常是 **3 层**。
*   这得益于非叶子节点只存索引，一个节点（16KB）能存上千个指针，3 层结构足以支撑两千万级别的数据。

---

### 37. 主键是用自增还是 UUID?

**回答：**

推荐用 **自增 ID**。
1.  **性能：** 既然 B+ 树是有序的，自增 ID 保证顺序插入，避免页分裂，减少随机 I/O。
2.  **存储：** BigInt (8字节) 比 UUID (36字节字符串) 占用空间小得多，能让 B+ 树节点容纳更多索引，降低树高。
3.  **场景：** 在分库分表场景下，自增 ID 无法保证全局唯一，此时可使用 **雪花算法 (Snowflake)** 生成的 ID（也就是有序的大整数），尽量避免使用随机 UUID。

# ## 索引篇

### 38. 普通索引和唯一索引有什么区别？哪个更新性能更好?

**分析**
哪个更新性能更好，要从 InnoDB 引擎的 change buffer 的角度去分析。

**回答**
普通索引列的值是可以重复的，而唯一索引列的值是必须唯一的，当我们对唯一索引插入了一条重复的值，会因为唯一性约束而报错。

我认为普通索引的更新性能会更好，因为普通索引在更新的时候，如果更新的数据页不在内存的话，可以直接把更新操作缓存在 change buffer 中，更新操作就结束了。但是，唯一索引因为需要有唯一性约束，如果更新的数据页不在内存的话，需要从磁盘读取对应的数据页到内存，判断到没有冲突，这里会涉及磁盘随机 IO 的访问。

普通索引因为能使用 change buffer 特性，所以普通索引的更新相比于唯一索引，减少了随机磁盘访问，所以更新性能更好。

> **推荐资料**：普通索引和唯一索引，应该怎么选择？.md

---

### 39. 主键怎么设置？追问：假如你不设置会怎么样？

**分析**
可以在创建表时，将某一列定义为主键（PRIMARY KEY）。例如:
```sql
CREATE TABLE table_name (
    id INT PRIMARY KEY,
    column1 datatype,
    column2 datatype
);
```

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：
*   如果有主键，默认会使用主键作为聚簇索引的索引键;
*   如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键;
*   在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键。

**回答**
在创建表的时候，对 id 列设置为 PRIMARY KEY，那么 id 列就是主键索引了。

**追问回答**
如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，如果这个条件也没有达成的话，InnoDB 将自动生成一个隐式 rowid 列作为聚簇索引的索引键。

> **推荐资料**：MySQL PRIMARY KEY 主键

---

### 40. 介绍一下什么是外键约束?

**分析**
先来看看什么是外键?
假设我们有 2 个表，分别是表 A 和表 B，它们通过一个公共字段 "id" 发生关联关系，我们把这个关联关系叫做 R。如果 "id" 在表 A 中是主键，那么，表 A 就是这个关系 R 中的主表。相应的，表 B 就是这个关系中的从表，表 B 中的 "id"，就是表 B 用来引用表 A 中数据的，叫外键。所以，外键就是「从表」中用来引用「主表」中数据的那个公共字段。

如图所示，在关联关系 R 中，公共字段（字段 A）是表 A 的主键，所以表 A 是主表，表 B 是从表。表 B 中的公共字段（字段 A）是外键。

**什么是外键约束？**
在 MySQL 中，外键是通过外键约束来定义的。外键约束就是约束的一种，它必须在从表中定义，包括指明哪个是外键字段，以及外键字段所引用的主表中的主键字段是什么。MySQL 系统会根据外键约束的定义，监控对主表中数据的删除操作。如果发现要删除的主表记录，正在被从表中某条记录的外键字段所引用，MySQL 就会提示错误，从而确保了关联数据不会缺失，保证了 2 个表中数据的一致性。

**回答**
外键就是「从表」中用来引用「主表」中数据的那个公共字段，外键约束确保了数据的引用完整性，也就是「从表」中的外键必须存在于「主表」的主键中，如果发现要删除的主表记录，正在被「从表」中某条记录的外键字段所引用，MySQL 就会提示错误，从而保证了 2 个表中数据的一致性。

> **推荐学习**：MySQL FOREIGN KEY 外键

---

### 41. 外键有什么优劣势?

**分析**
*   **一致性**：如果一个订单表引用了一个客户表的外键，外键可以确保订单的客户 ID 存在于客户表中，从而保持数据的一致性。
*   **性能问题 (Database Update Storm)**：所谓 Database Update Storm，指的是在高并发环境下，多个客户端同时对数据库进行大量的更新操作，存在锁竞争问题甚至死锁，从而导致数据库性能急剧下降或完全崩溃。因此，对于大并发的 SQL 操作，有可能会不适合用外键，比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。
*   **锁竞争问题**：在使用外键的情况下，每次修改数据都需要去检查外键关联表里的数据，这需要额外获取读锁，如果是高并发的情况下，更容易造成死锁。
*   **无法适用分库分表场景**：在大型项目中，当数据量特别大的时候，一般会采取分库分表来存储数据，但在不同的库中使用相同的外键来维护数据一致性和完整性是非常难的操作，外键难以跨越不同数据库来建立关系。所以在分布式、高并发集群的项目数据库中一般看不到外键能够保证数据的一致性和完整性，通过设置外键，数据库就会判断数据的完整性，不需要在应用代码里实现。

> **(注：以下内容衔接关于索引代价的分析)**

**索引的代价（补充知识点）**
*   **空间代价**：需要占用物理空间，数量越大，占用空间越大;
*   **时间代价**：会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大。

**回答 (关于索引缺点的考察)**
不是的。索引虽然能提高查询效率，但是多建立一个索引，就意味着新生成一个 B+树索引，是需要占用存储空间的，特别是在表数据量非常大的时候，索引占用的空间越大。还有，索引越多数据库的写入性能会下降，因为每次对表进行增删改操作的时候，都需要去维护各个 B+ 树索引的有序性。

建立了索引，虽然能提升查询效率，但是它带来了两个代价：
1.  **空间代价**：因为需要多构建一颗 B+ 树，会占用磁盘空间。
2.  **更新时间代价**：每次增删改索引，都需要动态维护 B+ 树，以满足 B+ 树的有序性。

所以，我认识到如果一张表经常被增删改的话，也就是写多读少的场景下，不建立索引会更好，因为这时候维护索引的开销可能会超过索引带来的性能提升。

还有一点，如果表中某个列的值高度重复，那么建了索引也没有用，优化器会选择全表扫描，这样建立的索引会占用存储空间，也会影响增删改的效率，选择不用索引会更好。

> **推荐学习**：第 7 章 好东西也得先学会怎么用-B+树索引的使用 (7.1 索引的代价)

---

### 46. 字段为什么要定义为 NOT NULL?

**分析**
**尽量避免 NULL**
很多表都包含可为 NULL (空值) 的列，即使应用程序并不需要保存 NULL 也是如此，这是因为可为 NULL 是列的默认属性。通常情况下最好指定列为 NOT NULL，除非真的需要存储 NULL 值。

**防止索引失效**
当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

如果索引列参与了计算，数据库同样无法使用索引进行查找。比如下面的例子，这里让索引列 `price` 参与了计算，数据库不能直接通过索引来确定符合条件的记录，只能全表扫描。
```sql
-- 假设 price 列有索引
SELECT * FROM products WHERE price + 10 < 100;
```

在使用 `LIKE` 进行模糊查询时，若通配符 `%` 位于开头，数据库无法使用索引进行查找。比如下面的例子，由于 `LIKE '%test'` 开头，数据库无法通过索引快速定位到满足条件的记录，只能全表扫描。不过，如果通配符不在开头，如 `LIKE 'test%'`，数据库仍可使用索引。

**隐式类型转换导致的索引失效**
```sql
-- 假设 name 列是字符串类型且有索引
SELECT * FROM users WHERE name = 123;
-- 背后的执行效果是:
select * from t_user where CAST(name AS signed int) = 123;
```

**OR 连接**
如果使用 OR 连接多个条件，且其中部分条件未使用索引，数据库可能不会使用索引。比如下面的例子，由于 user_name 列没有索引，数据库可能不会使用 `user_id` 列的索引，而是进行全表扫描。

**回答**
不是的。
我了解到即使查询使用到了索引，也是可能不走索引的，比如：
*   当我们查询语句对索引字段进行左模糊匹配、表达式计算、函数、隐式类型转换操作，这时候查询语句就无法走索引了，查询方式就变成了全表扫描的方式。
*   还有我们使用联合索引进行查询的时候，如果没有遵循最左匹配原则，也是会发生索引失效。

> **推荐学习**：索引出错：请理解 CBO 的工作原理.md

---

### 49. 如果我定义了一个 varchar 类型的日期字段... 还会命中索引吗？为什么？
*问题：如果我定义了一个 varchar 类型的日期字段，并且有一个数据是 '20230922'，如果这个日期字段上有索引，那如果我查询的 where 条件是 `where time=20230922` 不加单引号，还会命中索引吗？*

**分析**
不会命中索引。
要明白这个原因，首先我们要知道 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。那么这个字符串转为数字的过程，实际上背后会执行 CAST 函数。

```sql
//查询语句
select * from t_user where time = 20230922;

//背后的执行效果是：
select * from t_user where CAST(time AS signed int) = 20230922;
```

而题目中的字符串对象是 time，也就是索引字段，这时候 CAST 函数就会作用到 time 索引字段，相当于对索引字段进行了函数计算，因此就会发生索引失效。

而如果反过来，id 是索引且是整型类型，那么下面这条语句就不会发生索引失效，因为字符串对象是 "1"，是在它身上发生函数计算，id 并不会发生函数计算，所以没有问题。
```sql
//查询
select * from t_user where id = "1";
//等价于
select * from t_user where id = CAST("1" AS signed int);
```

**回答**
不会命中索引。
因为 MySQL 在遇到字符串和数字比较的时候，会发生隐式类型转换，会将字符串的对象转为数字，这个转换的过程实际上会涉及到函数。你说的这个查询，日期字段是字符串，那么发生隐式类型转换的时候，就会作用在日期这个索引字段上，对索引进行函数计算的话，是会发生索引失效的。

> **推荐学习**：索引失效有哪些?

---

### 50. MySQL 最新版本解决了索引失效的哪些情况了吗?

以下是经过去除水印、修复乱码、校对文字并按照 Markdown 格式重新整理的内容：

---

# MySQL 索引与事务特性深度解析

## 1. MySQL 8.0 新特性：函数索引和索引跳跃扫描

**MySQL 最新版本解决了索引失效的哪些情况？**

### 1.1 函数索引
MySQL 8.0 增加了函数索引特性，即可以针对函数计算后的值建立一个索引。也就是说，该索引的值是函数计算后的结果，因此可以通过扫描索引来查询数据，解决了以往对字段使用函数导致索引失效的问题。

**示例：**
对 `length(name)` 的计算结果建立一个名为 `idx_name_length` 的索引：

```sql
ALTER TABLE t_user ADD KEY idx_name_length ((length(name)));
```

此时使用如下查询语句，就会走索引了：

```sql
EXPLAIN SELECT * FROM t_user WHERE length(name) = 6;
```

**执行计划结果：**

| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | SIMPLE | t_user | ref | idx_name_length | idx_name_length | 5 | const | 100 | NULL |

---

### 1.2 索引跳跃扫描机制 (Index Skip Scan)
MySQL 8.0 新增了索引跳跃扫描机制。在 MySQL 5.7 版本之前，使用联合索引时，如果不满足**最左前缀原则**，索引会失效。而 8.0 推出该特性后，即使不遵循最左前缀原则，在部分场景下依然可以使用联合索引，减少不必要的全表扫描。

**官方文档场景示例：**

```sql
CREATE TABLE t1 (f1 INT NOT NULL, f2 INT NOT NULL, PRIMARY KEY(f1, f2));
INSERT INTO t1 VALUES (1,1), (1,2), (1,3), (1,4), (1,5), (2,1), (2,2), (2,3), (2,4), (2,5);
INSERT INTO t1 SELECT f1, f2 + 5 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 10 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 20 FROM t1;
INSERT INTO t1 SELECT f1, f2 + 40 FROM t1;
ANALYZE TABLE t1;

-- 查询语句
EXPLAIN SELECT f1, f2 FROM t1 WHERE f2 > 40;
```

**对比分析：**
*   **MySQL 5.7.19**：执行计划 Extra 字段为 `Using where; Using index`（全索引扫描）。
*   **MySQL 8.0.20**：执行计划 Extra 字段为 `Using where; Using index for skip scan`。

**执行逻辑对比：**
*   **MySQL 5.7**：从索引中取出所有记录，按 `f2 > 40` 过滤。
*   **MySQL 8.0**：使用 Range 扫描代替全索引扫描。过程如下：
    1.  获取 `f1` 字段第一个唯一值（如 f1=1）。
    2.  构造 `f1=1 and f2 > 40` 进行范围查询。
    3.  获取 `f1` 字段第二个唯一值（如 f1=2）。
    4.  构造 `f1=2 and f2 > 40` 进行范围查询。
    5.  以此类推，最后合并结果。

**限制条件（了解即可）：**
1.  查询只能涉及一张表（多表关联无法使用）。
2.  查询 SQL 不能使用 `GROUP BY` 或 `DISTINCT`。
3.  查询字段必须是索引中的字段（即必须是覆盖索引，涉及回表无法使用）。
4.  组合索引形式限制：前导列（如 A）可以为空，但后续列（如 B, C）不能为空。

---

## 2. 联合索引与最左匹配原则

### 51. 什么是最左匹配原则？
**分析：**
要知道联合索引的结构才能理解。如果创建了一个 `(a, b, c)` 联合索引，其 B+ 树的排序顺序是：先按 `a` 排序；在 `a` 相同的情况下按 `b` 排序；在 `b` 相同的情况下按 `c` 排序。

**回答：**
基于上述存储特性，MySQL 会从联合索引的最左边列开始匹配查询条件，依次从左到右。
*   如果查询条件没有用到最左列，或者中间断开了，那么该列右边的所有列都无法利用索引进行查找。
*   **范围查询截断**：当查询条件中某个列使用了范围查询（如 `>`、`<`、`like`），该列可以用到索引，但该列后面的字段无法用到联合索引。

### 52. 建立联合索引有什么需要注意的？
**分析：**
字段顺序对效率影响很大。区分度大的字段应排在前面。
*   **区分度计算公式**：`count(distinct column) / count(*)`。
*   区分度越高，扫描的行数越少。
*   **区分度低的问题**：如性别字段，区分度很小。如果放在最左侧，优化器可能认为全表扫描更划算，从而忽略索引。

**回答：**
应把区分度大的字段排在联合索引的前面。如果区分度很低的字段放在最左侧，可能导致查询优化器选择全表扫描。

---

## 3. 索引下推 (Index Condition Pushdown, ICP)

### 53. 了解索引下推吗？什么情况下会下推到引擎层？
**分析：**
索引下推能减少回表操作，将 Server 层负责的部分过滤工作交给存储引擎层。

**示例：** 用户表联合索引 `(age, reward)`。
SQL：`SELECT * FROM t_user WHERE age > 20 AND reward = 100000;`

*   **没有索引下推（MySQL 5.6 之前）**：
    1.  存储引擎定位到 `age > 20` 的记录。
    2.  每条记录都回表查询完整数据返回给 Server 层。
    3.  Server 层判断 `reward = 100000`。
*   **使用索引下推**：
    1.  存储引擎定位到 `age > 20` 的记录。
    2.  **直接在二级索引中判断** `reward` 是否等于 100000。
    3.  如果不符合，直接跳过；如果符合，再执行回表拿到完整记录返回给 Server 层。

**回答：**
索引下推通过将部分过滤逻辑（即使该字段无法用于索引定位，但存在于索引中）下推到存储引擎，大大减少了回表次数，提高了查询效率。执行计划中 Extra 显示 `Using index condition` 即代表使用了索引下推。

---

## 4. 联合索引实战题目

### 54. 联合索引 (a, b, c)，以下语句是否走索引？
1.  `where a=1 and b=2 and c=3`：**走索引**。符合最左匹配。
2.  `where a=1 and b>2 and c=3`：`a` 和 `b` 走索引。`c` 无法走索引（因 `b` 是范围查询），但 `c` 可以使用**索引下推**。
3.  `where c=1 and a=2 and b=3`：**走索引**。优化器会自动调整顺序为 `a=2 and b=3 and c=1`。
4.  `where a=2 and c=3`：`a` 走索引。`c` 无法走索引（中间断了 `b`），但 `c` 可以**索引下推**。（注：8.0 跳跃扫描可能适用，但一般面试指 5.7）。
5.  `where b=2 and c=3`：**不走索引**（不满足最左匹配）。
6.  `select (a,b) from T where a=1 and b>2`：**走索引**。覆盖索引，不需要回表。

### 55. `where a>1 and b=2 and c<3` 怎么建立索引？
**分析：**
`a` 是范围查询，如果放在第一位，后面的字段无法利用索引。应将等值查询 `b` 放在前面。
**回答：**
创建 **(b, a, c)** 或 **(b, c, a)** 联合索引。
*   **(b, a, c)**：`b` (等值) 和 `a` (范围) 走索引。`c` 可以索引下推。
*   **(b, c, a)**：`b` (等值) 和 `c` (范围) 走索引。`a` 可以索引下推。
这样都能保证至少两个字段走索引。

### 56. `where a=? and b=? order by c` 怎么建立索引？
**回答：**
建立 **(a, b, c)** 联合索引。满足 `a` 和 `b` 等值后，索引天然按 `c` 有序，避免了 `Using filesort`。

### 57. `where a>100 and b=100 and c=123 order by d` 怎么建立索引？
**分析：**
*   如果 `(b, c, a, d)`：`b`、`c` 是等值，走索引；`a` 是范围，走索引；但 `a` 范围查询后，`d` 不再有序，需要 Filesort。
*   如果 `(b, c, d, a)`：`b`、`c` 走索引；`d` 可以利用索引排序（因为前缀是等值）；`a` 无法走索引定位（只能索引下推）。
**回答：**
建立 **(b, c, d, a)** 索引比较好。`b` 和 `c` 利用索引查找，`d` 利用索引排序（避免 Filesort），`a` 使用索引下推，减少回表次数。

### 59. `select id, name from XX where age > 10 and name like 'xx%'`，联合索引 (name, age)
**分析：**
1.  **能不能走索引？** 能。`name` 是右模糊匹配（`xx%`），符合最左匹配，走索引。
2.  **Age 能否走索引？** 不能。因为 `name` 模糊匹配后，`age` 无序。但 `age` 可以**索引下推**。
3.  **是否回表？** 查询 `id`（主键）和 `name`（在索引中），是**覆盖索引**，不需要回表。

---

## 5. 事务与隔离级别

### 66. MySQL 事务和 Redis 事务的区别？
（文档中未详细展开，但指出了重点）

### 70. MySQL 默认隔离级别是什么？怎么实现的？
**回答：**
默认是 **可重复读 (Repeatable Read, RR)**。
*   **快照读 (Select)**：通过 **MVCC (多版本并发控制)** 实现。事务开启后第一次 Select 生成 Read View，后续复用，保证一致性。
*   **当前读 (Select for update / Update)**：通过 **行级锁 (Record Lock, Gap Lock, Next-Key Lock)** 保证。

### 71. 介绍一下 MVCC
**回答：**
MVCC（多版本并发控制）通过在每条记录后保存两个隐藏列（`trx_id` 事务ID, `roll_pointer` 回滚指针）来实现。
核心是 **Read View**，包含四个字段：
1.  `m_ids`: 创建时活跃未提交的事务 ID 列表。
2.  `min_trx_id`: 活跃事务中最小的 ID。
3.  `max_trx_id`: 下一个将被分配的事务 ID。
4.  `creator_trx_id`: 创建该 Read View 的事务 ID。

**可见性规则：**
通过对比记录的 `trx_id` 和 Read View 的字段，结合 Undo Log 版本链，判断数据对当前事务是否可见。

### 73. 读已提交 (RC)和可重复读 (RR) 实现 MVCC 的区别？
**回答：**
区别在于 **生成 Read View 的时机不同**：
*   **读已提交 (RC)**：**每次执行 Select 语句**时都会重新生成一个 Read View。
*   **可重复读 (RR)**：**启动事务后第一次执行 Select 语句**时生成 Read View，后续查询复用该 Read View。

### 76-78. 可重复读是否完全解决了幻读？
**回答：**
RR 级别 **很大程度上避免了幻读，但没有完全解决**。
*   **快照读**：靠 MVCC 解决。
*   **当前读**：靠 Next-Key Lock（临键锁）解决。

**发生幻读的特殊场景：**
1.  **先快照读，再当前读**：事务 A 先 Select（快照读，无记录），事务 B 插入记录并提交，事务 A 再 `Select ... for update`（当前读），就会读到事务 B 插入的记录，发生幻读。
2.  **更新“不存在”的记录**：事务 A 查询无记录，事务 B 插入并提交。事务 A 执行 Update 语句（Update 是当前读）更新了事务 B 刚插入的记录，导致该记录的 `trx_id` 变为事务 A 的 ID，之后事务 A 再 Select 就能看到这条记录了。

**建议：** 尽量在事务开启后立即执行 `select for update` 锁定范围。

---

## 6. 长事务与锁

### 80. 一个事务里有特别多 SQL 的弊端（长事务）？
**回答：**
1.  **锁占用时间长**：容易导致大量死锁和锁超时，阻塞其他业务。
2.  **Undo Log 堆积**：回滚记录占用大量磁盘空间，且回滚时间极长。
3.  **主从延迟**：主库执行完才写 Binlog，导致从库长时间无法同步。
4.  **连接池耗尽**：占用连接资源不释放。

### 81. MySQL 锁的分类
*   **全局锁**：全库逻辑备份（FTWRL）。
*   **表级锁**：
    *   **表锁**。
    *   **元数据锁 (MDL)**：操作表数据加 MDL 读锁，修改表结构加 MDL 写锁。
    *   **意向锁**。
*   **行级锁 (InnoDB 特有)**：
    *   **记录锁 (Record Lock)**：锁住一条记录。
    *   **间隙锁 (Gap Lock)**：锁住间隙，防止插入（解决幻读）。
    *   **临键锁 (Next-Key Lock)**：记录锁 + 间隙锁。
    *   **插入意向锁**。

### 82. MySQL 怎么实现乐观锁？
**分析：**
乐观锁假设并发冲突少，不加锁，只在更新时检查。
**实现方式：**
1.  **版本号机制**：表增加 `version` 字段。
    ```sql
    UPDATE products SET count = count-1, version = version+1 
    WHERE id=1 AND version = old_version;
    ```
    如果不影响行数，说明被修改过，重试。
2.  **时间戳机制**。
**适用场景**：读多写少。

### 84. 创建索引的时候会锁表吗？
**回答：**
会。修改表结构（如创建索引）会加 **MDL 写锁**。如果此时有长事务正在读写表（持有 MDL 读锁），创建索引的操作会被阻塞，且后续所有对该表的增删改查都会被阻塞（锁队列机制），可能导致生产事故。

### 85. InnoDB 的行级锁有哪些？
1.  **Record Lock (记录锁)**：锁住索引记录。
2.  **Gap Lock (间隙锁)**：RR 级别下存在，锁住索引记录之间的间隙，防止插入，解决幻读。
3.  **Next-Key Lock (临键锁)**：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身。
4.  **Insert Intention Lock (插入意向锁)**：插入时如果遇到间隙锁，会生成插入意向锁并阻塞。
## 锁机制

### 84. 创建索引的时候会锁表吗?

**分析**
对表结构修改，增加字段，删除字段，增加索引，删除索引，更改索引名字，更改字段名字等等，这些操作都会加 MDL 写锁（元数据写锁），属于表级锁，会和 MDL 读锁发生读写冲突。

**回答**
会的，创建索引的时候会加 MDL 写锁。如果这时候有其他事务对这张表进行增删查改的话，这些事务就都会被阻塞。原因是有事务对这张表进行读写操作的时候，会生成 MDL 读锁，这时候就产生了读写冲突。

### 85. Innodb 存储引擎中的行级锁有哪些？(重要)

**分析**
主要是有「记录锁、间隙锁、临键锁、插入意向锁」。

1.  **记录锁 (Record Lock)**
    Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的:
    *   当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）。
    *   当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁，也不可以对该记录加 X 型记录锁。

    举个例子，当一个事务执行了下面这条语句：
    ```sql
    mysql > begin;
    mysql > select * from t_test where id = 1 for update;
    ```
    就是对 `t_test` 表中主键 `id` 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。当事务执行 commit 后，事务过程中生成的锁都会被释放。

2.  **间隙锁 (Gap Lock)**
    Gap Lock 称为间隙锁，只存在于可重复读隔离级别和串行化隔离级（读已提交隔离级别不存在间隙锁），目的是为了解决可重复读隔离级别下幻读的现象。
    假设表中有一个范围 id 为 (3, 5) 的间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。
    间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。

3.  **临键锁 (Next-Key Lock)**
    Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
    假设表中有一个范围 id 为 (3, 5] 的 next-key lock，那么其他事务既不能插入 id = 4 记录，也不能修改 id = 5 这条记录。所以，next-key lock 既能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。
    Next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。

4.  **插入意向锁 (Insert Intention Lock)**
    一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
    如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻）。在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。
    插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。
    插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁。

**回答**
Innodb 实现的行级锁有记录锁、间隙锁、临键锁、插入意向锁。我们在使用增删改或者锁定读语句的时候，都会对记录加行级锁。
*   **记录锁**：可以避免其他事务对该记录进行删除和更新操作。
*   **间隙锁**：可以避免其他事务往间隙里插入新记录。
*   **临键锁**：是记录锁和间隙锁的组合，既可以免其他事务对该记录进行删除和更新操作，也可以避免其他事务往间隙里插入新记录。
*   **插入意向锁**：插入意向锁和间隙锁是互斥的关系，其他事务插入的时候，发现插入位置的下一条记录有间隙锁的话，才会生成的插入意向锁，并且这时候锁的状态是阻塞状态，目的是告诉用户插入的位置存在间隙锁。

### 86. 间隙锁的工作原理是什么?

**分析**
间隙锁是可重复读隔离级别和串行化隔离级别下才有的锁（读已提交隔离级别只有记录锁，没有间隙锁），主要是为了防止幻读的问题，它可以阻止其他事务往间隙里插入新记录。

**回答**
间隙锁防止其他事务往间隙插入新记录，从而可以避免幻读的问题。
具体的原理是：当其他事务插入记录的时候，当发现插入位置的下一条记录有间隙锁，就会生成插入意向锁，然后锁设置为阻塞状态，目的是告诉用户插入的位置存在间隙锁。

### 87. 一条 Update 语句没有带 where 条件, 加的是什么锁?

**分析**
Innodb 加锁是索引加锁，可重复读级别下，加锁的基本单位是 next-key 锁。读已提交隔离级别下，加锁的基本单位是记录锁。更新没有带 where 条件，会全表扫描，会对每一条记录都加锁。

**回答**
*   **可重复读级别下**：更新没有带 where 条件，会全表扫描，会对每一条记录都加 next-key 锁，相当于锁住了全表。
*   **读已提交隔离级别下**：没有间隙锁，更新没有带 where 条件，是全表扫描，那么会对每一条记录都加记录锁。

### 88. 带了 where 条件没有命中索引，加的是什么锁?

**回答**
没有命中索引，是全表扫描，那么:
*   **在可重复读级别下**：全表扫描的话，会对每一条记录都加 next-key 锁。
*   **在读已提交隔离级别下**：因为没有间隙锁，全表扫描的时候，会对每一条记录都加记录锁。

### 89. 两条更新语句更新同一条记录，加的是什么锁?

**分析**
这个题目更新同一条记录，就认为是等值查询的场景。要考虑这几种情况：

1.  **第一种情况：如果更新条件的字段是唯一索引，加什么锁?**
    当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：
    *   当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。
    *   当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」。

2.  **第二种情况：如果更新条件的字段是非唯一索引，加什么锁?**
    *   当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描。在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。
    *   当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。

3.  **第三种情况：没有使用索引**
    如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。

**回答**
在可重复读级别下，可能有这些情况：
*   **如果更新条件的字段是唯一索引，还要看更新的记录是否存在:**
    *   如果存在，那么这条记录加的记录锁，只锁住该条记录。
    *   如果这条记录不存在，则加间隙锁。
*   **如果更新条件的字段是非唯一索引，还要看更新的记录是否存在:**
    *   如果存在，由于非唯一索引会存在相同值的记录，所以非唯一索引等值查询实际上是一个扫描的过程，会针对符合更新条件的二级索引记录加 next-key 锁，最后扫描到第一个不符合更新条件的二级索引记录就会停止扫描，然后对第一个不符合更新条件的记录加间隙锁，同时，在符合更新条件的记录的主键索引上加记录锁。
    *   如果不存在，会对第一个不符合更新条件的二级索引记录加间隙锁。
*   **如果更新条件的字段是没有索引或者没有命中索引:**
    *   那么就是全表扫描，会对每一条记录都加 next-key 锁。

### 90. 两条更新语句更新同一条记录的不同字段，加的是什么锁?

**分析**
Innodb 加锁是加在行记录索引上的，不是针对更新的字段加锁。所以是不是更新同一个字段，没有关系。只要在这条记录上有更新操作，就会对这条记录加锁。所以这题的加锁的情况，也跟上一题一样。

**回答**
在可重复读级别下，情况与 Q89 相同，取决于索引类型和记录是否存在（参考上一题答案）。Innodb 的锁是加在索引上的，与具体更新哪个字段无关。

### 91. 可重复读场景，下面的场景会发生什么?

**题目描述**
现有表 `(id, no, name, age, score)`，数据如下：
(15, S0001, Bob, 25, 34), (18, S0002, Alice, 24, 77), (20, S0003, Jim, 24, 5), (30, S0004, Eric, 23, 91), (37, S0005, Tom, 22, 22), (49, S0006, Tom, 25, 83), (50, S0007, Rose, 23, 89)

**执行流程**
*   **Time 1 (事务A)**: `update students set score=100 where id=25;`
*   **Time 2 (事务B)**: `update students set score=100 where id=26;`
*   **Time 3 (事务A)**: `insert into students... values(25, ...);` (阻塞)
*   **Time 4 (事务B)**: `insert into students... values(26, ...);` (阻塞)

**分析**
这题要注意的是事务 A 和事务 B 更新语句，都是更新不存在的 id，这时候会加间隙锁。
1.  事务 A 更新 id=25（不存在），锁定范围 (20, 30) 的间隙锁。
2.  事务 B 更新 id=26（不存在），同样请求并获取范围 (20, 30) 的间隙锁（间隙锁之间兼容）。
3.  事务 A 插入 id=25，需要获取插入意向锁，但被事务 B 的间隙锁阻塞。
4.  事务 B 插入 id=26，需要获取插入意向锁，但被事务 A 的间隙锁阻塞。
5.  都在相互等待对方释放间隙锁，于是就发生了死锁。

**回答**
事务 A 和事务 B 在执行完 update 语句后都持有范围为 (20, 30) 的间隙锁。
而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件（互斥、占有且等待、不可强占用、循环等待），因此发生了死锁。

### 92. 了解过 MySQL 死锁问题吗?

**分析**
解释 MySQL 死锁是如何发生的。

**回答**
了解过。在并发事务中，当两个事务出现循环资源依赖，这两个事务都在等待别的事务释放资源时，就会导致这两个事务都进入无限等待的状态，这时候就发生了死锁。
MySQL 的锁是在事务提交的时候才会释放的，所以可以通过缩短锁持有时间来降低死锁的概率。

---

## 日志系统

### 96. redo log 和 binlog 的区别和应用场景?

**分析**
redo log 和 binlog 主要有 4 个区别：

1.  **适用对象不同**：
    *   binlog 是 Server 层生成的日志，主要用于数据备份和主从复制。
    *   redo log 是 Innodb 存储引擎层生成的日志，用于 Crash-safe 能力。
2.  **文件格式/内容不同**：
    *   binlog 有三种格式（Statement, Row, Mixed），记录 SQL 语句或数据变更。
    *   redo log 是物理日志，记录的是在某个数据页做了什么修改。
3.  **写入方式不同**：
    *   binlog 是追加写，写满一个文件就创建一个新的文件继续写，保存的是全量的日志。
    *   redo log 是循环写，日志空间大小是固定的，写满就从头开始，保存未被刷入磁盘的脏页日志。
4.  **用途不同**：
    *   binlog 用于备份恢复、主从复制。
    *   redo log 用于掉电等故障恢复。

**回答**
*   **Binlog**：Server 层日志，追加写。用于备份恢复和主从复制。
*   **Redo log**：InnoDB 引擎日志，循环写，物理日志。用于掉电等故障恢复（Crash-safe）。

### 97. redo log 和 binlog 在恢复数据库有什么区别?

**回答**
*   **binlog** 是追加写，保存了所有对数据库的更新操作，可以用来恢复数据库某个时刻的数据或者全量恢复数据库数据。
*   **redo log** 是循环写，保存的是 Innodb 存储引擎对数据页所做的修改操作，用来恢复因中途 MySQL 断电丢失的脏页数据。

**追问：为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的?**
binlog 是 server 层的日志，不会记录 innodb 存储引擎层中有哪些数据页没有被刷盘。redo log 是 innodb 层的日志，可以记录哪些脏页没有被刷盘。崩溃恢复的时候，恢复的粒度更细，可以精确到需要恢复的数据页，而 binlog 保存的是全量日志，没办法做到这一点，所以崩溃恢复用的是 redo log。

### 99. binlog 的三种格式是什么?

**回答**
binlog 有 3 种格式类型，分别是 STATEMENT (默认格式)、ROW、MIXED，区别如下:
*   **STATEMENT**: 每一条修改数据的 SQL 都会被记录到 binlog 中，主从复制中 slave 端再根据 SQL 语句重现。
    *   *缺陷*：有动态函数的问题（如 `uuid` 或 `now`），会导致主从数据不一致。
*   **ROW**: 记录行数据最终被修改成什么样了。
    *   *优点*：不会出现动态函数问题。
    *   *缺陷*：每行数据的变化结果都会被记录，批量 update 会产生大量日志，使 binlog 文件过大。
*   **MIXED**: 包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式。

### 100. redo log 是怎么实现持久化的？

**回答**
事务执行过程更新的数据，并不是在事务提交的时候就把修改的数据刷入磁盘的，而是修改 buffer pool 中数据页，并标记为脏页，然后后台再找合适的时间刷盘。
为了防止数据库宕机导致脏页数据丢失，引入了 redo log。事务修改数据时，先写 redo log buffer，然后根据刷盘策略持久化到磁盘。

### 103. 两阶段提交的过程？

**分析**
两阶段提交是为了保证 redo log 和 binlog 逻辑一致，从而保证主从复制的时候不会出现数据不一致的问题。
事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态。

**过程**
1.  **Prepare 阶段**: 写入 redo log，并将 redo log 状态设置为 prepare。
2.  **Commit 阶段**: 写入 binlog，然后调用引擎的提交事务接口，将 redo log 状态设置为 commit。

**回答**
通过两阶段提交（Prepare 和 Commit），确保 redo log 和 binlog 要么都成功，要么都失败。如果 binlog 刷入磁盘，即使 redo log 没有设置 commit 状态，MySQL 重启的时候也会提交事务，保证了数据一致性。

### 104. Redo log 刷盘策略有哪三种?

**分析**
InnoDB 提供了参数 `innodb_flush_log_at_trx_commit` 控制 redo log 刷盘策略，可取值 0、1、2。

*   **参数 0**: 事务提交时，redo log 留在 redo log buffer 中。由后台线程每隔 1 秒写入 page cache 并调用 fsync 刷盘。
    *   *风险*：MySQL 进程崩溃会丢失 1 秒数据。
*   **参数 1 (默认)**: 每次事务提交时，都将 redo log 直接持久化到磁盘。
    *   *特点*：最安全，但性能最差。
*   **参数 2**: 每次事务提交时，将 redo log 写到操作系统的 page cache (文件系统缓存)，但不立即 fsync。
    *   *风险*：MySQL 崩溃不会丢数据，但操作系统崩溃或断电会丢失 1 秒数据。

**回答**
Redo log 刷盘策略主要有三种:
1.  **参数 0**: 提交时不刷盘，后续由后台线程每秒刷盘。性能最好，安全性最差（MySQL 挂了就丢数据）。
2.  **参数 1**: 提交时直接刷盘。安全性最高，性能最差。
3.  **参数 2**: 提交时写到系统缓存（Page Cache），由系统控制刷盘。安全性中等（系统挂了才丢数据），性能较好。

---

## 性能调优 (重要)

### 105. 怎么查看一条语句是否走了索引？

**分析**
考察 `explain` 执行计划输出的信息。

**回答**
可以通过 `explain` 查看 SQL 的执行计划，关注 `type` 字段。
*   如果 `type` 字段不是 `ALL` (全表扫描) 或 `index` (全索引扫描)，就代表是索引扫描的方式，这种情况就代表 SQL 走了索引。
*   还可以通过 `key` 字段，看这条查询实际用了哪个索引。
*   `type` 效率从低到高：ALL < index < range < ref < eq_ref < const。

### 106. extra 字段中的 using index 和 using where 的区别?

**回答**
*   **Using index**: 表示查询使用了**覆盖索引** (Covering Index)，所需数据只需在索引即可全部获得，不需要再到表中取数据（回表），效率很高。
*   **Using where**: 表示 MySQL 服务器将在存储引擎检索行后再进行过滤。即存储引擎返回的行并不一定满足 WHERE 条件，MySQL 层需要再做检查。

### 109. 深分页场景如何优化？

**分析**
分页通常使用 `limit` 加上偏移量实现。如 `limit 10000, 20`，MySQL 需要扫描 10020 条记录，抛弃前 10000 条。如果是二级索引，还涉及 10000 次回表，性能极差。

**回答**
分页最简单的实现是 use limit 子句。在深分页场景（如 `limit 10000, 20`），性能问题严重。
优化方式：
1.  **游标法 ("下一页" 模式)**:
    在业务上改进，将“第几页”改成“下一页”。记录上一页最后一条记录的 id，下次直接从该记录位置开始扫描。
    ```sql
    select * from t_player where score > prev_score order by score desc limit 20;
    ```
2.  **延迟关联 (覆盖索引 + 子查询)**:
    通过子查询只查询主键 ID（覆盖索引，不回表），然后主查询通过 ID 获取完整数据。
    ```sql
    select * from t_player where id in
    (select id from t_player order by score limit 10000, 20);
    ```

### 110. 如果 SQL 和索引都没问题，查询还是很慢怎么办?

**分析**
需要发散思维，往架构优化方向思考。

**回答**
*   **分批查询**: 将一个大查询拆分为多个小查询。
*   **增加缓存**: 热点数据放入 Redis，避免每次请求 MySQL。
*   **分表**: 数据量千万级以上，考虑水平分表，减少单表数据量。
*   **主从复制**: 读写分离，分摊读请求流量。
*   **分库**: 针对写多读少或高并发，分散请求到多个实例。

---

## 数据库架构与选型

### 111. SQL 和 NoSQL 数据库有什么区别?

**分析**
从数据存储、事务、扩展性等维度对比。

**回答**
SQL 和 NoSQL 数据库的区别主要有:

1.  **数据存储的区别**:
    *   **SQL (关系型)**: 如 MySQL。数据严格按照二维表格存储，结构固定（Schema），表之间可建立连接。
    *   **NoSQL (非关系型)**: 如 Redis, MongoDB。数据存储灵活（Key-Value, 文档, 图等），无固定 Schema 约束。

2.  **事务的区别**:
    *   **SQL**: 支持 ACID 四大特性，适合对事务要求高的场景。
    *   **NoSQL**: 通常不完全支持 ACID，遵循 BASE 理论，牺牲一致性换取高性能。

3.  **扩展性的区别**:
    *   **SQL**: 数据存在关联，通常选择垂直扩展（升级硬件）。水平扩展（分库分表）难度大。
    *   **NoSQL**: 数据之间关联少，易于水平扩展。

**总结**: NoSQL 并非为了取代 SQL，而是互补。SQL 提供强事务，NoSQL 提供高扩展和高性能。


...被破坏。对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然越差。

### 关系型数据库（MySQL）的优劣势分析

**劣势：**
1.  **表结构扩展不方便**：由于数据库存储的是结构化数据，因此表结构 Schema 是固定的，扩展不方便。如果需要修改表结构，需要执行 DDL（Data Definition Language）语句修改，修改期间会导致锁表，部分服务不可用。
2.  **水平扩展后带来的种种问题难处理**：随着业务规模扩大，一种方式是对数据库做分库。做了分库之后，数据迁移（1 个库的数据按照一定规则打到 2 个库中）、跨库 JOIN、分布式事务处理都是需要考虑的问题。尤其是分布式事务处理，业界当前都没有特别好的解决方案。
3.  **为维护数据一致性付出的代价大**：数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也是非常大的。我们都知道 SQL 标准为事务定义了不同的隔离级别，从低到高依次是读未提交、读已提交、可重复读、串行化。事务隔离级别越低，可能出现的并发异常越多，但是通常而言能提供的并发能力越强。为了保证事务一致性，数据库就需要提供并发控制与故障恢复两种技术。

**优势：**
1.  **易于理解**：由二维表结构来逻辑表达，相对网状、层次等其他模型更加容易被理解。严格遵循数据格式与长度规范，数据以行为单位，一行数据表示一个实体信息，每一行数据的属性都是相同的。
2.  **操作方便**：通用的 SQL 语言使得操作关系型数据库非常方便，支持 JOIN 等复杂查询。SQL + 二维关系是关系型数据库最无可比拟的优点，这种易用性非常贴近开发者。
3.  **支持 ACID 特性**：可以维护数据之间的一致性，这是使用关系数据库非常重要的一个理由。例如银行转账，张三转给李四 100 块钱，张三扣 100 元，李四加 100 元，而且必须同时成功或者同时失败，否则就会造成用户的资损。

### NoSQL 数据库（MongoDB）的特性

MongoDB 是文档型 NoSQL 数据库，以 JSON 或者 XML 格式存储数据，因此文档型 NoSQL 是没有 Schema 的。由于没有 Schema 的特性，我们可以随意地存储与读取数据，因此文档型 NoSQL 的出现是解决关系型数据库表结构扩展不方便的问题的。

**优点：**
1.  没有预定义的字段，扩展字段容易。
2.  相较于关系型数据库，读写性能优越。命中二级索引的查询不会比关系型数据库慢，对于非索引字段的查询则是全面胜出。

---

## 高可用

### 113. MySQL 主从复制的过程是怎么样？

**分析：**

MySQL 主从复制过程梳理成 3 个阶段：
1.  **写入 binlog**：主库写 binlog 日志，提交事务，并更新本地存储数据。
2.  **同步 binlog**：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
3.  **回放 binlog**：回放 binlog，并更新存储引擎中的数据。

**回答：**

主从复制主要有 3 个阶段：
1.  **主库写入**：主库修改数据后，会写入 binlog 日志。从库连接到主库之后，主库会创建一个 `log dump` 线程，用于发送 binlog 的内容。
2.  **从库同步**：从库会创建一个专门的 `I/O 线程` 来连接主库的 `log dump` 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 `relay log`（中继日志）里，再返回给主库“复制成功”的响应。
3.  **从库回放**：接着从库还会创建一个用于回放 binlog 的 `SQL 线程`，去读 `relay log` 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。

### 114. MySQL 提供了几种复制模式？ 默认的复制模式是什么？

*(注：原文本此处未提供详细回答，直接跳至下一题)*

### 116. MySQL 主从架构中，读写分离怎么实现？

**分析：**

1.  **代码层实现**：一种简单的做法是：提前把所有数据源配置在工程中，每个数据源对应一个主库或者从库，然后改造代码，在代码逻辑中进行判断，将 SQL 语句发送给某一个指定的数据源来处理。这个方案简单易实现，但 SQL 路由规则侵入代码逻辑，在复杂的工程中不利于代码的维护。
2.  **中间件实现**：另一个做法是独立部署的代理中间件，如 **MyCat**。这一类中间件部署在独立的服务器上，一般使用标准的 MySQL 通信协议，可以代理多个数据库。该方案的优点是隔离底层数据库与上层应用的访问复杂度，比较适合有独立运维团队的公司选型；缺陷是所有的 SQL 语句都要跨两次网络传输，有一定的性能损耗，再就是运维中间件是一个专业且复杂的工作，需要一定的技术沉淀。

**回答：**

可以独立部署的代理中间件 MyCat 来实现读写分离。

### 117. MySQL 主库挂了怎么办？

**分析：**

MySQL 没有像 Redis 集群有哨兵模式，可以自动将从库升级为主库。MySQL 的“发现主服务器宕机~处理故障转移逻辑”要由数据库高可用套件完成，常用的是 **MHA**。

MHA 是一款开源的 MySQL 高可用程序，它由两大组件所组成：`MHA Manager` 和 `MHA Node`。
*   **MHA Manager**：通常部署在一台服务器上，用来判断多个 MySQL 高可用组是否可用。当发现有主服务器发生宕机，就发起 failover 操作。MHA Manager 可以看作是 failover 的总控服务器。
*   **MHA Node**：部署在每台 MySQL 服务器上，MHA Manager 通过执行 Node 节点的脚本完成 failover 切换操作。

MySQL 的高可用套件用于负责数据库的 Failover 操作，也就是当数据库发生宕机时，MySQL 可以剔除原有主机，选出新的主机，然后对外提供服务，保证业务的连续性。

**回答：**

MySQL 主从复制没有实现发现主服务器宕机和处理故障迁移的功能。要实现自动主从故障迁移的话，可以使用开源的 MySQL 高可用套件 **MHA**。MHA 可以在主数据库发生宕机时，剔除原有主机，选出新的主机，然后对外提供服务，保证业务的连续性。

### 118. 什么是分库分表？什么时候需要分表？什么时候需要分库？

**分析：**

分库分表使用的场景不一样：
*   **分表**是因为数据量比较大，导致事务执行缓慢。
*   **分库**是因为单库的性能无法满足要求。

**回答：**

分库分表的意思把原本存储于单个数据库上的数据拆分到多个数据库，把原来存储在单张数据表的数据拆分到多张数据表中，实现数据切分。分库分表使用的场景不一样：

1.  **分表**：当单张数据表的数据量太大的时候（经验值是 **500W** 以上的数据量），就会影响了事务的执行效率，这时候就要考虑分表了，通过减少每次查询数据总量来解决数据查询缓慢的问题。
2.  **分库**：当单台 MySQL 扛不住高并发流量的时候，就要考虑分库了，把并发请求分散到多台 MySQL 实例中。

### 119. 分库分表后，会产生什么问题？怎么解决？

**分析：**

1.  **分布式事务问题**：
    *   2PC 两阶段、3PC 三阶段提交协议（强一致性，性能差，用的少）。
    *   TCC 分段提交、基于本地消息表来实现分布式事务（最终一致性，性能较好，用的多）。
2.  **全局 ID 唯一性问题**：
    *   雪花算法生成 ID、或者美团 Leaf 算法生成唯一主键 ID。
3.  **跨库跨表关联查询问题**：
    *   冗余额外字段避免跨库关联，或者交给数据库分库分表中间件来实现。
    *   将数据全量存储到 ES（Elasticsearch）中去，通过 ES 进行查询。
4.  **跨库跨表的排序问题**：
    *   业务代码或者数据库分库分表中间件分别查询每个子表中的数据，然后汇总进行排序。
    *   将聚合查询的数据同步到 ES 中，交给 ES 进行查询。

**回答：**

*   **分布式事务问题**：对业务进行分库之后，同一个操作会分散到多个数据库中，涉及跨库执行 SQL 语句，也就出现了分布式事务问题。解决方式：如果对一致性要求比较高的业务（比如金融类），可以使用分布式事务中间件，实现 **TCC 事务模型**；互联网的业务通常对一致性要求低，会使用**基于本地消息表**来实现分布式事务，达到最终一致性的效果，这个方案性能会好一些。
*   **全局 ID 唯一性问题**：在单库单表时，业务 ID 可以依赖数据库的自增主键实现，进行分库分表之后，如果还是用数据库的自增主键，可能会导致主键重复。我们可以通过**雪花算法**或者**美团 Leaf 算法**生成唯一主键 ID。
*   **跨库跨表关联查询问题**：分库分表后，跨库和跨表的查询操作实现起来会比较复杂，我们可以通过**冗余额外字段**避免跨库关联，或者交给数据库分库分表中间件来实现，也可以将数据全量存储到 **ES** 中去，通过 ES 进行查询。
*   **跨库跨表的排序问题**：分库分表以后，数据分散存储到不同的数据库和表中，如果需要对数据列表进行排序时，就变得异常复杂。我们可以通过业务代码或者数据库分库分表中间件分别查询每个子表中的数据，然后**汇总进行排序**，也可以将数据全量存储到 ES 中去，通过 ES 进行查询。
*   **跨库跨表 COUNT 查询的问题**：分库分表以后，数据分散存储到不同的数据库和表中，如果需要对表进行 COUNT 查询就会很复杂，我们可以将计数的数据单独存储在一张表里，或者将聚合查询的数据同步到 ES 中，交给 ES 进行查询。