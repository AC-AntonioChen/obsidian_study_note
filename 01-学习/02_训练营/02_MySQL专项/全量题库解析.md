
## SQL 语法

### 1. count(主键) 和 count(非主键) 结果会不同吗?

**分析：**

`count()` 函数是返回表中某个列的非 NULL 值的数量。

*   **count(主键)：** 由于主键的列不能存 NULL 值，所以 count(主键) 返回的结果，可以表示数据库表中所有行数据的数量。
*   **count(非主键)：** 由于非主键的列可以存 NULL 值，那么 count(非主键) 返回表中非主键列的非 NULL 值的数量。

**回答：**

主键是不能存 NULL 值的，所以 count 主键代表统计表中所有行数据的数量。
而非主键是可以存 NULL 值的，所以 Count 非主键统计的是表中这个列的非 NULL 值的数量。

**推荐学习：** `count(*)` 和 `count(1)` 有什么区别？哪个性能最好?

---

### 2. MySQL 内连接、外连接有什么区别?

**分析：**

*   **内连接（INNER JOIN）：** 内连接返回两个表中匹配的行，即只返回两个表中共有的数据。
*   **外连接（OUTER JOIN）：** 外连接则返回两个表中匹配和不匹配的行。MySQL 外连接主要有左外连接（LEFT JOIN）、右外连接（RIGHT JOIN）两种。
    *   **左连接（LEFT JOIN）：** `SELECT * FROM A LEFT JOIN B ON A.A_id = B.B_id`，将返回左表 A 中的所有行和右表 B 中与之匹配的行。如果 B 表中没有匹配的行，则 B 表相关的列使用 NULL 值填充。
    *   **右连接（RIGHT JOIN）：** `SELECT * FROM A RIGHT JOIN B ON A.A_id = B.B_id`，将返回右表 B 中的所有行和左表 A 中与之匹配的行。如果 A 表中没有匹配的行，则 A 表相关的列使用 NULL 值填充。

**回答：**

内连接和外连接都是用于连表查询。
*   **内连接**是只返回两个表匹配的数据行。
*   **外连接**可以返回两个表匹配和不匹配的数据行，外连接主要分为左连接和右连接。
    *   左连接返回左表中的所有行和右表中匹配的行，如果右表中没有匹配的行，则用 NULL 值填充。
    *   右连接返回右表中的所有行和左表中匹配的行，如果左表中没有匹配的行，则用 NULL 值填充。

---

### 3. 外连接时 ON 和 WHERE 过滤条件区别?

**分析：**

*   **内连接：** 对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。在内连接中，`WHERE` 子句和 `ON` 子句是等价的。
*   **外连接：**
    *   **WHERE 子句：** 不论是内连接还是外连接，凡是不符合 WHERE 子句中过滤条件的记录都不会被加入最后的结果集。它是在连接操作之后执行的进一步筛选。
    *   **ON 子句：** 专门为外连接设计的。驱动表中的记录即使在被驱动表中没有匹配的记录（即 ON 条件不满足），也仍然需要加入到结果集（对应的被驱动表字段填充 NULL）。ON 中的过滤条件在连接时进行。

**回答：**

在外连接中，使用 ON 和 WHERE 过滤条件的区别在于：
*   **ON** 中的过滤条件在连接时进行，用于决定是否匹配被驱动表的数据，即使不匹配，驱动表的行也会保留。
*   **WHERE** 用于指定过滤条件，对连接后的结果集进行进一步筛选，凡是不满足 WHERE 条件的都会被过滤掉。

---

### 4. HAVING 与 WHERE 的区别?

**分析：**

*   **WHERE** 子句在 `GROUP BY` 分组和聚合函数之前对数据行进行过滤，WHERE 子句无法使用聚合函数。
*   **HAVING** 子句对 `GROUP BY` 分组和聚合函数之后的数据行进行过滤，HAVING 子句可以使用聚合函数。

**回答：**

在 GROUP BY 分组查询过程中：
*   **WHERE** 是工作在 GROUP BY 之前，是对分组之前的数据进行筛选，无法使用聚合函数。
*   **HAVING** 是工作在 GROUP BY 之后，主要对分组之后的数据进行筛选，可以使用聚合函数。

---

### 5. IN 和 EXISTS 的区别?

**代码块：**
```sql
-- 使用 IN
select * from A where id in (select id from B);

-- 使用 EXISTS
select * from A where exists (select 1 from B where A.id=B.id);
```

**性能区别分析：**

*   **IN：** 当 B 表数据较大时不适合使用 `IN()`，因为它会把 B 表数据全部遍历一次（类似于 `for(A) { for(B) }`）。如果 A 表是小表，B 表是大表，效率很差。
*   **EXISTS：** 适合 B 表比 A 表大的情况。
*   **总结：** 当 A 表（外表）与 B 表（内表）数据一样大时，IN 与 EXISTS 效率差不多，可选一个使用。当 B 表数据较大时，EXISTS 效率优于 IN。

---

### 6. 数据库常见约束有哪些?

**分析：**

*   **唯一性约束 (Unique)：** 保证字段在表中的数值是唯一的，如果插入相同字段值的记录，就会报唯一性约束的错误。
*   **非空约束 (Not Null)：** 保证字段不能为 NULL。
*   **默认约束 (Default)：** 给字段设置默认值，如果插入数据的时候，这个字段没有取值的话，就会用默认值。

---

### 7. DELETE、DROP、TRUNCATE 有什么区别?

**分析：**

| 区别点 | DROP | TRUNCATE | DELETE |
| :--- | :--- | :--- | :--- |
| **执行速度** | 快 | 较快 | 慢 |
| **命令分类** | DDL (数据定义语言) | DDL (数据定义语言) | DML (数据操作语言) |
| **回滚** | 不可回滚 | 不可回滚 | 可回滚 |
| **自增初始值** | 重置 | 重置 | 不重置 |
| **空间释放** | 释放表空间 | 释放表空间 (保留结构) | 不释放 (仅标记) |

**回答：**

1.  **DELETE：** 是删除表中的数据，可以选择删除部分或全部。DELETE 删除的数据是可以回滚的。它是给数据打上删除标记，目的是为了空间复用，磁盘文件大小不会缩减。
2.  **DROP：** 是删除表结构和表中所有的数据，立刻释放磁盘空间。
3.  **TRUNCATE：** 是只删除表中所有的记录（数据清空），表结构保持不变，重置 ID。
4.  **性能排序：** `DROP > TRUNCATE > DELETE`。

---

### 8. 联合查询中 UNION 和 UNION ALL 的区别是什么?

**分析：**

*   **UNION：** 用于合并多个查询结果，并**去除重复**的行。查询结果中的重复行只会被包含一次。
*   **UNION ALL：** 也用于合并多个查询结果，但**不会去除重复**的行。

**回答：**

*   **UNION：** 在合并结果集后会自动剔除重复的行。
*   **UNION ALL：** 则会保留所有的重复行，不会进行去重操作，因此效率通常比 UNION 高。

---

### 9. 数据库范式与反范式

**分析：**

*   **范式化 (Normalization)：** 旨在消除数据冗余，避免更新异常、插入异常，保证数据的一致性和完整性。通常会将数据分解为多个表。
*   **反范式化：** 在实际应用中，范式化导致查询需要进行大量的表连接操作，成本很高。因此有时会进行反范式设计，通过字段冗余来避免联表查询，提高读取性能。

**回答：**

范式化将数据分解为多个表，那么查询数据的时候，就需要进行更多的表连接操作。在应用中，进行表关联的成本是很高，也不适合分库分表的场景。所以有时候实际应用设计表的时候会**反范式**，比如说可以通过字段冗余的设计，避免联表查询。

---

### 10. count(*) 性能比 count(1) 好吗?

**分析：**

按照性能排序：`count(*) = count(1) > count(主键字段) > count(字段)`

MySQL 会将 `count(*)` 参数转化为参数 0 来处理（`count(0)`），所以在执行过程中，`count(*)` 和 `count(1)` 的执行过程基本是一样的，性能没有什么差异。

**回答：**

不是的。MySQL 会将星号参数转化为参数 0 来处理，所以 `count(*)` 和 `count(1)` 性能是一样的。

---

### 11. 说一说执行一条查询 SQL 语句的全过程

**分析：**

MySQL 整体架构流程：
1.  **连接器：** 建立连接、校验身份。
2.  **查询缓存：** (MySQL 8.0 已删除) 查找缓存，命中则直接返回。
3.  **解析器：** 词法分析、语法分析，构建语法树。
4.  **优化器：** 计算查询成本，选择索引，生成执行计划。
5.  **执行器：** 根据执行计划调用存储引擎接口。
6.  **存储引擎：** 读取记录返回给执行器。

**回答：**

MySQL 执行一条查询 SQL 语句的时候，会经过连接器、查询缓存、解析器、优化器、执行器、存储引擎这些模块。

1.  首先 MySQL 的**连接器**会负责建立连接、校验用户身份。
2.  第二步，**查询缓存**（8.0版本已删），如果命中直接返回。
3.  第三步，**解析器**对 SQL 进行词法和语法分析，构建语法树。
4.  第四步，**优化器**基于查询成本选择最小的执行计划（如选择索引）。
5.  第五步，**执行器**根据执行计划从**存储引擎**读取记录，返回给客户端。

## 存储引擎

### 12. MySQL 存储引擎有哪些?

**分析：**

MySQL 整体分为 Server 层和存储引擎层。常见的引擎有 InnoDB, MyISAM, Memory, Archive, CSV 等。

**回答：**

MySQL 常见的存储引擎有 InnoDB、MyISAM、Memory。
*   **InnoDB：** 是 MySQL 默认的存储引擎，支持事务和行级锁，具有崩溃恢复功能。
*   **MyISAM：** 不支持事务和行级锁（只支持表锁），适合读多写少的场景。
*   **Memory：** 数据存储在内存中，读写快，但数据不具备持久性（断电丢失），适合临时存储。

---

### 13. MyISAM 和 InnoDB 存储引擎有什么区别?

**分析：**

| 特性 | InnoDB | MyISAM |
| :--- | :--- | :--- |
| **事务** | 支持 | 不支持 |
| **锁** | 支持行锁和表锁 | 仅支持表锁 |
| **外键** | 支持 | 不支持 |
| **恢复性** | 支持 (Redo Log) | 无事务日志 |
| **表结构** | 索引组织表 (数据即索引) | 堆表 (数据索引分离) |
| **索引叶节点** | 存储完整数据 | 存储数据地址 |

**回答：**

1.  **数据存储：** InnoDB 采用索引组织表（聚簇索引），数据和索引存在同一个文件；MyISAM 采用堆表，数据和索引分开存储。
2.  **锁粒度：** InnoDB 支持行级锁，并发性能好；MyISAM 只支持表锁。
3.  **事务：** InnoDB 支持事务（ACID），MyISAM 不支持。
4.  **查询性能：** InnoDB 利用聚簇索引主键查询极快；MyISAM 记录插入顺序存储，更新索引需更新地址。

---

### 14. MySQL 为什么选择 InnoDB 作为默认引擎?

**回答：**

InnoDB 引擎在事务支持、并发性能、崩溃恢复等方面具有优势：
*   **事务支持：** 支持 ACID 特性，而 MyISAM 不支持。
*   **并发性能：** 采用行级锁，相比 MyISAM 的表锁，锁粒度更小，并发高。
*   **崩溃恢复：** 通过 Redo Log 实现崩溃恢复，保证数据持久性。

---

### 16. NULL 值是如何存储的?

**分析：**

MySQL 行格式中包含一个“NULL 值列表”。
*   如果存在允许 NULL 值的列，则每个列对应一个二进制位 (bit)。
*   二进制位为 1 代表该列为 NULL，为 0 代表不为 NULL。
*   这个列表逆序排列。

**回答：**

MySQL 行格式中会用**「NULL 值列表」**来标记值为 NULL 的列。每个列对应一个二进制位，如果列的值为 NULL，就会标记二进制位为 1，否则为 0。所以 NULL 值并不会存储在行格式中的真实数据部分，而是存储在行头信息的 NULL 值列表中，至少占用 1 字节空间。

---

### 17. CHAR 和 VARCHAR 有什么区别？哪个性能更好?

**分析：**

*   **CHAR：** 固定长度。不管实际存多少，都占定义长度（不足补空格）。
*   **VARCHAR：** 可变长度。占用实际长度 + 额外长度标识（1-2字节）。
*   **性能：** 理论上 CHAR 略快（CPU 指令少），但 VARCHAR 节省空间，减少磁盘 I/O。当 Buffer Pool 足够大时，差别不大；当 I/O 是瓶颈时，VARCHAR 可能更好。

**回答：**

*   **CHAR** 是固定长度，不足会自动填充空格。
*   **VARCHAR** 是可变长度，只占用实际长度 + 长度前缀。
*   **性能：** 站在 CPU 角度，CHAR 更快（定长好计算）；站在磁盘 I/O 角度，VARCHAR 更短，I/O 效率可能更高。总体来看，在内存充足时差别不大。

---

### 18. 假如说一个字段是 varchar(10)，但它其实只有 6 个字节，那他在内存中占的存储空间是多少？在文件中占的存储空间是多少?

**回答：**

*   **文件存储：** 会占用 6 字节数据 + 1 字节长度标识（共 7 字节）。
*   **内存占用：** MySQL 内存引擎通常会分配固定大小的内存块（基于最大定义长度）来保存内部值，所以内存中可能会按 `varchar(10)` 的最大定义来分配，以避免碎片和频繁重分配。

---

### 19. 如果硬件内存特别大，MySQL 缓存能否替代 Redis?

**分析：**

MySQL 是面向磁盘设计的（Buffer Pool, Undo/Redo Log, 锁机制），首要目标是减少 I/O。Redis 是面向内存设计的（O(1) 访问，无复杂事务锁开销）。

**回答：**

**不能。**
即使 Buffer Pool 无限大，MySQL 的性能依然不如 Redis：
1.  MySQL 查询需要走 B+ 树搜索（O(logN)），Redis Hash 查找是 O(1)。
2.  MySQL 为了事务隔离性有复杂的加锁机制，Redis 单线程（核心模型）无此开销。
3.  MySQL 有 WAL（写前日志）刷盘机制。

## 索引结构

### 20. MySQL 有哪些索引类型?

**回答：**

MySQL 主要支持：
*   **B+ 树索引：** InnoDB 默认，支持排序、分组、范围查询。
*   **Hash 索引：** Memory 引擎支持，仅支持精确匹配，不支持范围。
*   **全文索引 (Full-text)：** 用于文本搜索。

---

### 22. B+ 树的特性是什么?

**回答：**

B+ 树是一个多叉平衡查找树，主要特性有：
1.  **非叶子节点不存数据：** 只存储索引（路由信息），让树更扁平，一次 I/O 读入更多索引。
2.  **所有数据都在叶子节点：** 数据存储在叶子节点，且按顺序存放。
3.  **双向链表：** 所有叶子节点通过双向指针串联，方便范围查询和全表扫描。

---

### 23. B+ 树和 B 树有什么区别?

**回答：**

1.  **数据位置：** B 树所有节点都存储索引+数据；B+ 树只有叶子节点存数据，非叶子节点只存索引。这使得 B+ 树更“矮胖”，磁盘 I/O 次数更少。
2.  **范围查询：** B+ 树叶子节点由链表连接，范围查询只需遍历链表；B 树需要中序遍历，效率较低。
3.  **稳定性：** B+ 树每次查询都要走到叶子节点，查询耗时稳定。

---

### 24. MySQL 为什么使用 B+ 树?

**回答：**

1.  **磁盘读写代价低：** 非叶子节点不存数据，节点能容纳更多索引，树更矮，减少 I/O。
2.  **便于范围查询：** 叶子节点的双向链表天然支持范围查询（Range Scan）。
3.  **性能稳定：** 所有查询都必须到达叶子节点。

---

### 27. 为什么索引用 B+ 树？而不用哈希表?

**回答：**

*   **哈希表 (Hash)：** 虽然单条查询快 (O(1))，但是数据是散列分布的，无序。**无法进行范围查询、排序、模糊查询**。
*   **B+ 树：** 有序结构，完美支持范围查询和排序，且磁盘读写效率高。

---

### 29. 聚簇索引和非聚簇索引有什么区别?

**分析：**

*   **聚簇索引 (Clustered Index)：** 叶子节点存储「主键值 + 完整的行记录」。(InnoDB 主键索引)
*   **非聚簇索引 (Secondary Index)：** 叶子节点存储「索引列值 + 主键值」。

**回答：**

最主要区别是 **B+ 树叶子节点存放的内容不同**：
*   **聚簇索引：** 存放主键值和完整记录。
*   **非聚簇索引（二级索引）：** 存放索引值和主键值。
*   **查询差异：** 如果查二级索引且需要获取完整数据，需要先拿到主键，再回表到聚簇索引查数据（回表）。

---

### 30. 什么是覆盖索引?

**回答：**

当查询的列（SELECT ...）能够在二级索引的叶子节点中全部找到（例如查主键或索引本身的列），就**不需要回到主键索引（聚簇索引）去查行记录了**。这种不需要“回表”的过程，就叫覆盖索引，效率极高。

---

### 31. 什么情况下会回表?

**回答：**

在使用二级索引查询时，如果查询的列不能在二级索引中全部找到（例如 `SELECT *`），MySQL 只能先通过二级索引找到对应的主键 ID，然后再拿着这个 ID 去聚簇索引（主键索引）中查找完整的行记录。这个过程叫“回表”，需要扫描两棵 B+ 树。

---

### 32. Insert 操作对 B+ 树结构的改变 (页分裂)?

**回答：**

*   **自增主键：** 顺序插入，数据追加在当前页尾部，页满开辟新页，效率高。
*   **随机主键 (如 UUID)：** 插入值随机，可能插入到已有数据页的中间。如果该页已满，需要将数据移动、分割成两个页（**页分裂**）。
*   **后果：** 页分裂导致大量的内存碎片，索引结构不紧凑，增加随机 I/O，严重影响性能。

---

### 33. 假如一张表有两千万数据，B+ 树高度是多少?

**回答：**

具体取决于字段大小。假设一行记录 1KB，主键 ID 为 BigInt。
一般情况下，MySQL InnoDB 的 B+ 树高度通常是 **3 层**。
*   这得益于非叶子节点只存索引，一个节点（16KB）能存上千个指针，3 层结构足以支撑两千万级别的数据。

---

### 37. 主键是用自增还是 UUID?

**回答：**

推荐用 **自增 ID**。
1.  **性能：** 既然 B+ 树是有序的，自增 ID 保证顺序插入，避免页分裂，减少随机 I/O。
2.  **存储：** BigInt (8字节) 比 UUID (36字节字符串) 占用空间小得多，能让 B+ 树节点容纳更多索引，降低树高。
3.  **场景：** 在分库分表场景下，自增 ID 无法保证全局唯一，此时可使用 **雪花算法 (Snowflake)** 生成的 ID（也就是有序的大整数），尽量避免使用随机 UUID。

# ## 索引篇

### 38. 普通索引和唯一索引有什么区别？哪个更新性能更好?

**分析**
哪个更新性能更好，要从 InnoDB 引擎的 change buffer 的角度去分析。

**回答**
普通索引列的值是可以重复的，而唯一索引列的值是必须唯一的，当我们对唯一索引插入了一条重复的值，会因为唯一性约束而报错。

我认为普通索引的更新性能会更好，因为普通索引在更新的时候，如果更新的数据页不在内存的话，可以直接把更新操作缓存在 change buffer 中，更新操作就结束了。但是，唯一索引因为需要有唯一性约束，如果更新的数据页不在内存的话，需要从磁盘读取对应的数据页到内存，判断到没有冲突，这里会涉及磁盘随机 IO 的访问。

普通索引因为能使用 change buffer 特性，所以普通索引的更新相比于唯一索引，减少了随机磁盘访问，所以更新性能更好。

> **推荐资料**：普通索引和唯一索引，应该怎么选择？.md

---

### 39. 主键怎么设置？追问：假如你不设置会怎么样？

**分析**
可以在创建表时，将某一列定义为主键（PRIMARY KEY）。例如:
```sql
CREATE TABLE table_name (
    id INT PRIMARY KEY,
    column1 datatype,
    column2 datatype
);
```

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：
*   如果有主键，默认会使用主键作为聚簇索引的索引键;
*   如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键;
*   在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键。

**回答**
在创建表的时候，对 id 列设置为 PRIMARY KEY，那么 id 列就是主键索引了。

**追问回答**
如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键，如果这个条件也没有达成的话，InnoDB 将自动生成一个隐式 rowid 列作为聚簇索引的索引键。

> **推荐资料**：MySQL PRIMARY KEY 主键

---

### 40. 介绍一下什么是外键约束?

**分析**
先来看看什么是外键?
假设我们有 2 个表，分别是表 A 和表 B，它们通过一个公共字段 "id" 发生关联关系，我们把这个关联关系叫做 R。如果 "id" 在表 A 中是主键，那么，表 A 就是这个关系 R 中的主表。相应的，表 B 就是这个关系中的从表，表 B 中的 "id"，就是表 B 用来引用表 A 中数据的，叫外键。所以，外键就是「从表」中用来引用「主表」中数据的那个公共字段。

如图所示，在关联关系 R 中，公共字段（字段 A）是表 A 的主键，所以表 A 是主表，表 B 是从表。表 B 中的公共字段（字段 A）是外键。

**什么是外键约束？**
在 MySQL 中，外键是通过外键约束来定义的。外键约束就是约束的一种，它必须在从表中定义，包括指明哪个是外键字段，以及外键字段所引用的主表中的主键字段是什么。MySQL 系统会根据外键约束的定义，监控对主表中数据的删除操作。如果发现要删除的主表记录，正在被从表中某条记录的外键字段所引用，MySQL 就会提示错误，从而确保了关联数据不会缺失，保证了 2 个表中数据的一致性。

**回答**
外键就是「从表」中用来引用「主表」中数据的那个公共字段，外键约束确保了数据的引用完整性，也就是「从表」中的外键必须存在于「主表」的主键中，如果发现要删除的主表记录，正在被「从表」中某条记录的外键字段所引用，MySQL 就会提示错误，从而保证了 2 个表中数据的一致性。

> **推荐学习**：MySQL FOREIGN KEY 外键

---

### 41. 外键有什么优劣势?

**分析**
*   **一致性**：如果一个订单表引用了一个客户表的外键，外键可以确保订单的客户 ID 存在于客户表中，从而保持数据的一致性。
*   **性能问题 (Database Update Storm)**：所谓 Database Update Storm，指的是在高并发环境下，多个客户端同时对数据库进行大量的更新操作，存在锁竞争问题甚至死锁，从而导致数据库性能急剧下降或完全崩溃。因此，对于大并发的 SQL 操作，有可能会不适合用外键，比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。
*   **锁竞争问题**：在使用外键的情况下，每次修改数据都需要去检查外键关联表里的数据，这需要额外获取读锁，如果是高并发的情况下，更容易造成死锁。
*   **无法适用分库分表场景**：在大型项目中，当数据量特别大的时候，一般会采取分库分表来存储数据，但在不同的库中使用相同的外键来维护数据一致性和完整性是非常难的操作，外键难以跨越不同数据库来建立关系。所以在分布式、高并发集群的项目数据库中一般看不到外键能够保证数据的一致性和完整性，通过设置外键，数据库就会判断数据的完整性，不需要在应用代码里实现。

> **(注：以下内容衔接关于索引代价的分析)**

**索引的代价（补充知识点）**
*   **空间代价**：需要占用物理空间，数量越大，占用空间越大;
*   **时间代价**：会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大。

**回答 (关于索引缺点的考察)**
不是的。索引虽然能提高查询效率，但是多建立一个索引，就意味着新生成一个 B+树索引，是需要占用存储空间的，特别是在表数据量非常大的时候，索引占用的空间越大。还有，索引越多数据库的写入性能会下降，因为每次对表进行增删改操作的时候，都需要去维护各个 B+ 树索引的有序性。

建立了索引，虽然能提升查询效率，但是它带来了两个代价：
1.  **空间代价**：因为需要多构建一颗 B+ 树，会占用磁盘空间。
2.  **更新时间代价**：每次增删改索引，都需要动态维护 B+ 树，以满足 B+ 树的有序性。

所以，我认识到如果一张表经常被增删改的话，也就是写多读少的场景下，不建立索引会更好，因为这时候维护索引的开销可能会超过索引带来的性能提升。

还有一点，如果表中某个列的值高度重复，那么建了索引也没有用，优化器会选择全表扫描，这样建立的索引会占用存储空间，也会影响增删改的效率，选择不用索引会更好。

> **推荐学习**：第 7 章 好东西也得先学会怎么用-B+树索引的使用 (7.1 索引的代价)

---

### 46. 字段为什么要定义为 NOT NULL?

**分析**
**尽量避免 NULL**
很多表都包含可为 NULL (空值) 的列，即使应用程序并不需要保存 NULL 也是如此，这是因为可为 NULL 是列的默认属性。通常情况下最好指定列为 NOT NULL，除非真的需要存储 NULL 值。

**防止索引失效**
当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

如果索引列参与了计算，数据库同样无法使用索引进行查找。比如下面的例子，这里让索引列 `price` 参与了计算，数据库不能直接通过索引来确定符合条件的记录，只能全表扫描。
```sql
-- 假设 price 列有索引
SELECT * FROM products WHERE price + 10 < 100;
```

在使用 `LIKE` 进行模糊查询时，若通配符 `%` 位于开头，数据库无法使用索引进行查找。比如下面的例子，由于 `LIKE '%test'` 开头，数据库无法通过索引快速定位到满足条件的记录，只能全表扫描。不过，如果通配符不在开头，如 `LIKE 'test%'`，数据库仍可使用索引。

**隐式类型转换导致的索引失效**
```sql
-- 假设 name 列是字符串类型且有索引
SELECT * FROM users WHERE name = 123;
-- 背后的执行效果是:
select * from t_user where CAST(name AS signed int) = 123;
```

**OR 连接**
如果使用 OR 连接多个条件，且其中部分条件未使用索引，数据库可能不会使用索引。比如下面的例子，由于 user_name 列没有索引，数据库可能不会使用 `user_id` 列的索引，而是进行全表扫描。

**回答**
不是的。
我了解到即使查询使用到了索引，也是可能不走索引的，比如：
*   当我们查询语句对索引字段进行左模糊匹配、表达式计算、函数、隐式类型转换操作，这时候查询语句就无法走索引了，查询方式就变成了全表扫描的方式。
*   还有我们使用联合索引进行查询的时候，如果没有遵循最左匹配原则，也是会发生索引失效。

> **推荐学习**：索引出错：请理解 CBO 的工作原理.md

---

### 49. 如果我定义了一个 varchar 类型的日期字段... 还会命中索引吗？为什么？
*问题：如果我定义了一个 varchar 类型的日期字段，并且有一个数据是 '20230922'，如果这个日期字段上有索引，那如果我查询的 where 条件是 `where time=20230922` 不加单引号，还会命中索引吗？*

**分析**
不会命中索引。
要明白这个原因，首先我们要知道 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。那么这个字符串转为数字的过程，实际上背后会执行 CAST 函数。

```sql
//查询语句
select * from t_user where time = 20230922;

//背后的执行效果是：
select * from t_user where CAST(time AS signed int) = 20230922;
```

而题目中的字符串对象是 time，也就是索引字段，这时候 CAST 函数就会作用到 time 索引字段，相当于对索引字段进行了函数计算，因此就会发生索引失效。

而如果反过来，id 是索引且是整型类型，那么下面这条语句就不会发生索引失效，因为字符串对象是 "1"，是在它身上发生函数计算，id 并不会发生函数计算，所以没有问题。
```sql
//查询
select * from t_user where id = "1";
//等价于
select * from t_user where id = CAST("1" AS signed int);
```

**回答**
不会命中索引。
因为 MySQL 在遇到字符串和数字比较的时候，会发生隐式类型转换，会将字符串的对象转为数字，这个转换的过程实际上会涉及到函数。你说的这个查询，日期字段是字符串，那么发生隐式类型转换的时候，就会作用在日期这个索引字段上，对索引进行函数计算的话，是会发生索引失效的。

> **推荐学习**：索引失效有哪些?

---

### 50. MySQL 最新版本解决了索引失效的哪些情况了吗?

**分析**
MySQL 8.0 新特性：函数索引和索引跳跃扫描机制。

以下是将 OCR 文本清洗、整理并还原后的 Markdown 格式文档。根据内容逻辑，我将其分为四个大章节（锁机制、日志系统、性能调优、数据库选型）。

---

## 锁机制

### 84. 创建索引的时候会锁表吗?

**分析**
对表结构修改，增加字段，删除字段，增加索引，删除索引，更改索引名字，更改字段名字等等，这些操作都会加 MDL 写锁（元数据写锁），属于表级锁，会和 MDL 读锁发生读写冲突。

**回答**
会的，创建索引的时候会加 MDL 写锁。如果这时候有其他事务对这张表进行增删查改的话，这些事务就都会被阻塞。原因是有事务对这张表进行读写操作的时候，会生成 MDL 读锁，这时候就产生了读写冲突。

### 85. Innodb 存储引擎中的行级锁有哪些？(重要)

**分析**
主要是有「记录锁、间隙锁、临键锁、插入意向锁」。

1.  **记录锁 (Record Lock)**
    Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的:
    *   当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）。
    *   当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁，也不可以对该记录加 X 型记录锁。

    举个例子，当一个事务执行了下面这条语句：
    ```sql
    mysql > begin;
    mysql > select * from t_test where id = 1 for update;
    ```
    就是对 `t_test` 表中主键 `id` 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。当事务执行 commit 后，事务过程中生成的锁都会被释放。

2.  **间隙锁 (Gap Lock)**
    Gap Lock 称为间隙锁，只存在于可重复读隔离级别和串行化隔离级（读已提交隔离级别不存在间隙锁），目的是为了解决可重复读隔离级别下幻读的现象。
    假设表中有一个范围 id 为 (3, 5) 的间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。
    间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。

3.  **临键锁 (Next-Key Lock)**
    Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
    假设表中有一个范围 id 为 (3, 5] 的 next-key lock，那么其他事务既不能插入 id = 4 记录，也不能修改 id = 5 这条记录。所以，next-key lock 既能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。
    Next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。

4.  **插入意向锁 (Insert Intention Lock)**
    一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
    如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻）。在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。
    插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。
    插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁。

**回答**
Innodb 实现的行级锁有记录锁、间隙锁、临键锁、插入意向锁。我们在使用增删改或者锁定读语句的时候，都会对记录加行级锁。
*   **记录锁**：可以避免其他事务对该记录进行删除和更新操作。
*   **间隙锁**：可以避免其他事务往间隙里插入新记录。
*   **临键锁**：是记录锁和间隙锁的组合，既可以免其他事务对该记录进行删除和更新操作，也可以避免其他事务往间隙里插入新记录。
*   **插入意向锁**：插入意向锁和间隙锁是互斥的关系，其他事务插入的时候，发现插入位置的下一条记录有间隙锁的话，才会生成的插入意向锁，并且这时候锁的状态是阻塞状态，目的是告诉用户插入的位置存在间隙锁。

### 86. 间隙锁的工作原理是什么?

**分析**
间隙锁是可重复读隔离级别和串行化隔离级别下才有的锁（读已提交隔离级别只有记录锁，没有间隙锁），主要是为了防止幻读的问题，它可以阻止其他事务往间隙里插入新记录。

**回答**
间隙锁防止其他事务往间隙插入新记录，从而可以避免幻读的问题。
具体的原理是：当其他事务插入记录的时候，当发现插入位置的下一条记录有间隙锁，就会生成插入意向锁，然后锁设置为阻塞状态，目的是告诉用户插入的位置存在间隙锁。

### 87. 一条 Update 语句没有带 where 条件, 加的是什么锁?

**分析**
Innodb 加锁是索引加锁，可重复读级别下，加锁的基本单位是 next-key 锁。读已提交隔离级别下，加锁的基本单位是记录锁。更新没有带 where 条件，会全表扫描，会对每一条记录都加锁。

**回答**
*   **可重复读级别下**：更新没有带 where 条件，会全表扫描，会对每一条记录都加 next-key 锁，相当于锁住了全表。
*   **读已提交隔离级别下**：没有间隙锁，更新没有带 where 条件，是全表扫描，那么会对每一条记录都加记录锁。

### 88. 带了 where 条件没有命中索引，加的是什么锁?

**回答**
没有命中索引，是全表扫描，那么:
*   **在可重复读级别下**：全表扫描的话，会对每一条记录都加 next-key 锁。
*   **在读已提交隔离级别下**：因为没有间隙锁，全表扫描的时候，会对每一条记录都加记录锁。

### 89. 两条更新语句更新同一条记录，加的是什么锁?

**分析**
这个题目更新同一条记录，就认为是等值查询的场景。要考虑这几种情况：

1.  **第一种情况：如果更新条件的字段是唯一索引，加什么锁?**
    当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：
    *   当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。
    *   当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」。

2.  **第二种情况：如果更新条件的字段是非唯一索引，加什么锁?**
    *   当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描。在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。
    *   当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。

3.  **第三种情况：没有使用索引**
    如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。

**回答**
在可重复读级别下，可能有这些情况：
*   **如果更新条件的字段是唯一索引，还要看更新的记录是否存在:**
    *   如果存在，那么这条记录加的记录锁，只锁住该条记录。
    *   如果这条记录不存在，则加间隙锁。
*   **如果更新条件的字段是非唯一索引，还要看更新的记录是否存在:**
    *   如果存在，由于非唯一索引会存在相同值的记录，所以非唯一索引等值查询实际上是一个扫描的过程，会针对符合更新条件的二级索引记录加 next-key 锁，最后扫描到第一个不符合更新条件的二级索引记录就会停止扫描，然后对第一个不符合更新条件的记录加间隙锁，同时，在符合更新条件的记录的主键索引上加记录锁。
    *   如果不存在，会对第一个不符合更新条件的二级索引记录加间隙锁。
*   **如果更新条件的字段是没有索引或者没有命中索引:**
    *   那么就是全表扫描，会对每一条记录都加 next-key 锁。

### 90. 两条更新语句更新同一条记录的不同字段，加的是什么锁?

**分析**
Innodb 加锁是加在行记录索引上的，不是针对更新的字段加锁。所以是不是更新同一个字段，没有关系。只要在这条记录上有更新操作，就会对这条记录加锁。所以这题的加锁的情况，也跟上一题一样。

**回答**
在可重复读级别下，情况与 Q89 相同，取决于索引类型和记录是否存在（参考上一题答案）。Innodb 的锁是加在索引上的，与具体更新哪个字段无关。

### 91. 可重复读场景，下面的场景会发生什么?

**题目描述**
现有表 `(id, no, name, age, score)`，数据如下：
(15, S0001, Bob, 25, 34), (18, S0002, Alice, 24, 77), (20, S0003, Jim, 24, 5), (30, S0004, Eric, 23, 91), (37, S0005, Tom, 22, 22), (49, S0006, Tom, 25, 83), (50, S0007, Rose, 23, 89)

**执行流程**
*   **Time 1 (事务A)**: `update students set score=100 where id=25;`
*   **Time 2 (事务B)**: `update students set score=100 where id=26;`
*   **Time 3 (事务A)**: `insert into students... values(25, ...);` (阻塞)
*   **Time 4 (事务B)**: `insert into students... values(26, ...);` (阻塞)

**分析**
这题要注意的是事务 A 和事务 B 更新语句，都是更新不存在的 id，这时候会加间隙锁。
1.  事务 A 更新 id=25（不存在），锁定范围 (20, 30) 的间隙锁。
2.  事务 B 更新 id=26（不存在），同样请求并获取范围 (20, 30) 的间隙锁（间隙锁之间兼容）。
3.  事务 A 插入 id=25，需要获取插入意向锁，但被事务 B 的间隙锁阻塞。
4.  事务 B 插入 id=26，需要获取插入意向锁，但被事务 A 的间隙锁阻塞。
5.  都在相互等待对方释放间隙锁，于是就发生了死锁。

**回答**
事务 A 和事务 B 在执行完 update 语句后都持有范围为 (20, 30) 的间隙锁。
而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件（互斥、占有且等待、不可强占用、循环等待），因此发生了死锁。

### 92. 了解过 MySQL 死锁问题吗?

**分析**
解释 MySQL 死锁是如何发生的。

**回答**
了解过。在并发事务中，当两个事务出现循环资源依赖，这两个事务都在等待别的事务释放资源时，就会导致这两个事务都进入无限等待的状态，这时候就发生了死锁。
MySQL 的锁是在事务提交的时候才会释放的，所以可以通过缩短锁持有时间来降低死锁的概率。

---

## 日志系统

### 96. redo log 和 binlog 的区别和应用场景?

**分析**
redo log 和 binlog 主要有 4 个区别：

1.  **适用对象不同**：
    *   binlog 是 Server 层生成的日志，主要用于数据备份和主从复制。
    *   redo log 是 Innodb 存储引擎层生成的日志，用于 Crash-safe 能力。
2.  **文件格式/内容不同**：
    *   binlog 有三种格式（Statement, Row, Mixed），记录 SQL 语句或数据变更。
    *   redo log 是物理日志，记录的是在某个数据页做了什么修改。
3.  **写入方式不同**：
    *   binlog 是追加写，写满一个文件就创建一个新的文件继续写，保存的是全量的日志。
    *   redo log 是循环写，日志空间大小是固定的，写满就从头开始，保存未被刷入磁盘的脏页日志。
4.  **用途不同**：
    *   binlog 用于备份恢复、主从复制。
    *   redo log 用于掉电等故障恢复。

**回答**
*   **Binlog**：Server 层日志，追加写。用于备份恢复和主从复制。
*   **Redo log**：InnoDB 引擎日志，循环写，物理日志。用于掉电等故障恢复（Crash-safe）。

### 97. redo log 和 binlog 在恢复数据库有什么区别?

**回答**
*   **binlog** 是追加写，保存了所有对数据库的更新操作，可以用来恢复数据库某个时刻的数据或者全量恢复数据库数据。
*   **redo log** 是循环写，保存的是 Innodb 存储引擎对数据页所做的修改操作，用来恢复因中途 MySQL 断电丢失的脏页数据。

**追问：为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的?**
binlog 是 server 层的日志，不会记录 innodb 存储引擎层中有哪些数据页没有被刷盘。redo log 是 innodb 层的日志，可以记录哪些脏页没有被刷盘。崩溃恢复的时候，恢复的粒度更细，可以精确到需要恢复的数据页，而 binlog 保存的是全量日志，没办法做到这一点，所以崩溃恢复用的是 redo log。

### 99. binlog 的三种格式是什么?

**回答**
binlog 有 3 种格式类型，分别是 STATEMENT (默认格式)、ROW、MIXED，区别如下:
*   **STATEMENT**: 每一条修改数据的 SQL 都会被记录到 binlog 中，主从复制中 slave 端再根据 SQL 语句重现。
    *   *缺陷*：有动态函数的问题（如 `uuid` 或 `now`），会导致主从数据不一致。
*   **ROW**: 记录行数据最终被修改成什么样了。
    *   *优点*：不会出现动态函数问题。
    *   *缺陷*：每行数据的变化结果都会被记录，批量 update 会产生大量日志，使 binlog 文件过大。
*   **MIXED**: 包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式。

### 100. redo log 是怎么实现持久化的？

**回答**
事务执行过程更新的数据，并不是在事务提交的时候就把修改的数据刷入磁盘的，而是修改 buffer pool 中数据页，并标记为脏页，然后后台再找合适的时间刷盘。
为了防止数据库宕机导致脏页数据丢失，引入了 redo log。事务修改数据时，先写 redo log buffer，然后根据刷盘策略持久化到磁盘。

### 103. 两阶段提交的过程？

**分析**
两阶段提交是为了保证 redo log 和 binlog 逻辑一致，从而保证主从复制的时候不会出现数据不一致的问题。
事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态。

**过程**
1.  **Prepare 阶段**: 写入 redo log，并将 redo log 状态设置为 prepare。
2.  **Commit 阶段**: 写入 binlog，然后调用引擎的提交事务接口，将 redo log 状态设置为 commit。

**回答**
通过两阶段提交（Prepare 和 Commit），确保 redo log 和 binlog 要么都成功，要么都失败。如果 binlog 刷入磁盘，即使 redo log 没有设置 commit 状态，MySQL 重启的时候也会提交事务，保证了数据一致性。

### 104. Redo log 刷盘策略有哪三种?

**分析**
InnoDB 提供了参数 `innodb_flush_log_at_trx_commit` 控制 redo log 刷盘策略，可取值 0、1、2。

*   **参数 0**: 事务提交时，redo log 留在 redo log buffer 中。由后台线程每隔 1 秒写入 page cache 并调用 fsync 刷盘。
    *   *风险*：MySQL 进程崩溃会丢失 1 秒数据。
*   **参数 1 (默认)**: 每次事务提交时，都将 redo log 直接持久化到磁盘。
    *   *特点*：最安全，但性能最差。
*   **参数 2**: 每次事务提交时，将 redo log 写到操作系统的 page cache (文件系统缓存)，但不立即 fsync。
    *   *风险*：MySQL 崩溃不会丢数据，但操作系统崩溃或断电会丢失 1 秒数据。

**回答**
Redo log 刷盘策略主要有三种:
1.  **参数 0**: 提交时不刷盘，后续由后台线程每秒刷盘。性能最好，安全性最差（MySQL 挂了就丢数据）。
2.  **参数 1**: 提交时直接刷盘。安全性最高，性能最差。
3.  **参数 2**: 提交时写到系统缓存（Page Cache），由系统控制刷盘。安全性中等（系统挂了才丢数据），性能较好。

---

## 性能调优 (重要)

### 105. 怎么查看一条语句是否走了索引？

**分析**
考察 `explain` 执行计划输出的信息。

**回答**
可以通过 `explain` 查看 SQL 的执行计划，关注 `type` 字段。
*   如果 `type` 字段不是 `ALL` (全表扫描) 或 `index` (全索引扫描)，就代表是索引扫描的方式，这种情况就代表 SQL 走了索引。
*   还可以通过 `key` 字段，看这条查询实际用了哪个索引。
*   `type` 效率从低到高：ALL < index < range < ref < eq_ref < const。

### 106. extra 字段中的 using index 和 using where 的区别?

**回答**
*   **Using index**: 表示查询使用了**覆盖索引** (Covering Index)，所需数据只需在索引即可全部获得，不需要再到表中取数据（回表），效率很高。
*   **Using where**: 表示 MySQL 服务器将在存储引擎检索行后再进行过滤。即存储引擎返回的行并不一定满足 WHERE 条件，MySQL 层需要再做检查。

### 109. 深分页场景如何优化？

**分析**
分页通常使用 `limit` 加上偏移量实现。如 `limit 10000, 20`，MySQL 需要扫描 10020 条记录，抛弃前 10000 条。如果是二级索引，还涉及 10000 次回表，性能极差。

**回答**
分页最简单的实现是 use limit 子句。在深分页场景（如 `limit 10000, 20`），性能问题严重。
优化方式：
1.  **游标法 ("下一页" 模式)**:
    在业务上改进，将“第几页”改成“下一页”。记录上一页最后一条记录的 id，下次直接从该记录位置开始扫描。
    ```sql
    select * from t_player where score > prev_score order by score desc limit 20;
    ```
2.  **延迟关联 (覆盖索引 + 子查询)**:
    通过子查询只查询主键 ID（覆盖索引，不回表），然后主查询通过 ID 获取完整数据。
    ```sql
    select * from t_player where id in
    (select id from t_player order by score limit 10000, 20);
    ```

### 110. 如果 SQL 和索引都没问题，查询还是很慢怎么办?

**分析**
需要发散思维，往架构优化方向思考。

**回答**
*   **分批查询**: 将一个大查询拆分为多个小查询。
*   **增加缓存**: 热点数据放入 Redis，避免每次请求 MySQL。
*   **分表**: 数据量千万级以上，考虑水平分表，减少单表数据量。
*   **主从复制**: 读写分离，分摊读请求流量。
*   **分库**: 针对写多读少或高并发，分散请求到多个实例。

---

## 数据库架构与选型

### 111. SQL 和 NoSQL 数据库有什么区别?

**分析**
从数据存储、事务、扩展性等维度对比。

**回答**
SQL 和 NoSQL 数据库的区别主要有:

1.  **数据存储的区别**:
    *   **SQL (关系型)**: 如 MySQL。数据严格按照二维表格存储，结构固定（Schema），表之间可建立连接。
    *   **NoSQL (非关系型)**: 如 Redis, MongoDB。数据存储灵活（Key-Value, 文档, 图等），无固定 Schema 约束。

2.  **事务的区别**:
    *   **SQL**: 支持 ACID 四大特性，适合对事务要求高的场景。
    *   **NoSQL**: 通常不完全支持 ACID，遵循 BASE 理论，牺牲一致性换取高性能。

3.  **扩展性的区别**:
    *   **SQL**: 数据存在关联，通常选择垂直扩展（升级硬件）。水平扩展（分库分表）难度大。
    *   **NoSQL**: 数据之间关联少，易于水平扩展。

**总结**: NoSQL 并非为了取代 SQL，而是互补。SQL 提供强事务，NoSQL 提供高扩展和高性能。