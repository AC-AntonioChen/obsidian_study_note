## 1.1 Java
### 1.1.1 接口和抽象类？
“接口用于定义多类共有的行为规范，支持多继承且无实现细节；抽象类提取子类共性，允许部分方法实现并强制单继承。例如，设计缓存模块时，用接口定义 `Cache` 的存储方法，用抽象类 `AbstractCache` 实现公共的缓存过期逻辑，供不同子类扩展。
#### 1.1.1.1 如何选择接口还是抽象类？
- 优先用接口：需多继承、强调行为规范、模块解耦时。
- 用抽象类：需复用代码、定义类族共性、限制子类结构时‌
### 1.1.2 hashmap 的底层实现是什么
JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过扰动函数处理过后得到 hash 值，然后通过 `(n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

`HashMap` 中的扰动函数（`hash` 方法）是用来优化哈希值的分布。通过对原始的 `hashCode()` 进行额外处理，扰动函数可以减小由于糟糕的 `hashCode()` 实现导致的碰撞，从而提高数据的分布均匀性。

## 1.2 Database
### 1.2.1 Mysql如何分库分表，水平垂直划分如何实现？
“MySQL 分库分表主要通过垂直和水平两种方式。垂直划分是按列或业务拆分，比如把用户表和订单表分到不同库，或者把用户基础字段和详情字段分到不同表。水平划分是按数据行拆分，比如按用户 ID 哈希分 4 个库，每个库再按月分表。实现时可以用 ShardingSphere 中间件自动路由，解决全局 ID 和跨库查询问题。不过要谨慎评估是否真的需要分库分表，因为会带来复杂度提升。”


## 1.3 消息队列
## 1.4 Redis
