## 1 Java基础
### 1.1 Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？
short，int，long，float，double,boolean，char，byte
Short,Integer,Long,Float,Double,Boolean，Character，Byte
占用字节：
short：2byte （-2^15 至 2^15-1，即-32768 到 32767）
int :4byte（ ‌-2³¹ 到 2³¹-1‌（约±21亿））
long：8byte
float：4byte（1位符号位+8位指数位+23位尾数：尾数 * （2^指数）），约6~7位十进制
double：8byte(1+11+52)，约15~17位十进制
boolean：通常用1bit存储，但根据jvm实现有差异
char：2byte，Unicode字符，范围 \u0000 到 \uffff（0 到 65535）。
byte：1byte，-2⁷ 至 2⁷-1（-128 到 127）
### 1.2 String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?
1. ‌**String**‌：不可变字符序列，任何修改操作（如拼接）会生成新对象。适用于字符串不频繁修改的场景。
2. ‌**StringBuffer**‌：可变字符序列，线程安全（方法用`synchronized`修饰），性能较低，适用于多线程环境。
3. ‌**StringBuilder**‌：可变字符序列，线程不安全，性能较高，适用于单线程环境。

String不可变的原因是：
（1）String类本身使用了final作为修饰，使得类对象本身不可变
（2）String类中用于实际存储字符信息的char[]数组，是private final的,并且不提供修改char[]的数组的方法。
### 1.3 String s1 = new String("abc"); 这段代码创建了⼏个字符串对象？
- 若`"abc"`首次出现：创建‌**2个对象**‌（1个常量池对象 + 1个堆对象）。
- 若`"abc"`已存在常量池：创建‌**1个对象**‌（仅堆对象）。
字面量仅在‌**首次出现**‌时触发常量池对象创建
### 4. == 与 equals?hashCode 与 equals ?
```
对于基础类型，==比较值是否相等，没有equals方法
对于对象类型，==比较两个对象的地址是否相等，equals默认也是比较地址是否相等，如果重写了equals方法，就会按照equals方法的逻辑进行比较，例如对于Integer类型，equals方法被重写为比较整数数值是否相等。
```

hashCode 与 equals 有这样的强制契约:
（1）如果对象A equals 对象B，那么两个对象的hashcode必须一致，**这样才能使哈希集合正确的处理该对象类型**
（2）如果对象A和对象B的hashcode一致，那么这两个对象可以不相等，也就是允许出现哈希碰撞

hashCode 与 equals 必须同时重写。

### 5. 包装类型的缓存机制了解么？
包装类型的缓存机制如下：
（1）Integer的缓存机制是使用了一个cache， Integer类型在类加载时会执行一段往cache中存放-128到127字面量的逻辑，这样在声明值为-128到127的Integer，当使用自动装箱字面量来定义包装类型对象时，就可以直接复用cache中已有的对象。Integer的缓存上限127可通过JVM参数 `-XX:AutoBoxCacheMax` 调整（例如扩展至200）
（2）Boolean的缓存机制是在类加载时就直接把True跟False缓存起来。
（3）Short也是缓存-128到127，但不能调整缓存池上限
（4）Long也是缓存-128到127，但不能调整缓存池上限
（5）Character仅缓存0~127，刚好覆盖标准ASCII字符集
（6）Byte缓存-128到127
（7）‌**Float 和 Double 无缓存**‌：自动装箱时始终生成新对象‌

### 6. ⾃动装箱与拆箱了解吗？原理是什么？
自动装箱跟自动拆箱实际上都是编译器行为。

自动装箱是编译器将字面量转成包装类型的过程。实际上是调用valueOf方法，比如Integer a = 1；在编译后，就会变成Integer a = Integer.valueOf(1)；

自动拆箱则是编译器将包装类型转成字面量的过程，实际上是调用了XXXValue()，比如intValue()，doubleValue() ，所以当包装类型被赋值null后再自动拆箱会出现空指针问题。

频繁拆装箱会增加开销，装箱会涉及对象创建，而拆箱则需从堆内存对象中提取值并进行类型检查，可能还会涉及强制类型转换

### 7. 深拷⻉和浅拷⻉区别了解吗？什么是引⽤拷⻉？
‌**深拷贝**‌：完全复制原始对象及其所有嵌套引用的对象，生成一个完全独立的副本。
‌**浅拷贝**‌：仅复制原始对象的字段值（**基本类型直接复制，引用类型复制地址**），副本与原对象共享引用字段指向的对象。
Object.clone() 默认是浅拷贝‌，需重写 clone() 并递归处理引用字段才能实现深拷贝。
‌**引用拷贝**‌：仅创建新的引用变量指向同一对象，没有对象复制行为。例如：
User a = new User();  
User b = a;  // 引用拷贝，修改 b 会影响 a  
### 8. 谈谈对 Java 注解的理解，解决了什么问题？
Java注解Annotation是一种为代码(类，方法，参数)提供结构化元数据的增强方式，本质上是通过@interface语法定义的接口，通过编译器或者运行时框架解析。
从分类上说，注解一般有内置注解，元注解跟自定义注解。
注解主要解决的问题：
	（1）解耦配置与代码，提升代码可读性：取代传统bean的xml配置方式，通过声明式注解，如@Component直接在代码中嵌入配置信息
	（2）标准化扩展能力：为框架提供统一的扩展点。
		例如编译时可以通过@Override校验方法重写逻辑
			运行时Spring框架可以通过@Autowired实现自动注入，所以注解也常用来实现需要的aop业务逻辑如日志打印，事务管理等

### 9. Exception 和 Error 有什么区别？
Java 异常体系的根类是 **Throwable**，其直接子类为 Error 和 Exception。

‌Error‌ 表示 JVM 无法处理的严重问题（如 OutOfMemoryError），属于非受检异常，程序不应捕获。
‌Exception‌ 分为两类：
‌受检异常‌（如 IOException）：必须通过 try-catch 或 throws 显式处理。
‌非受检异常‌：即 RuntimeException 及其子类（如空指针异常），由代码逻辑错误引发，编译时不强制处理。
### 10. Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？
反射是Java在运行时动态获取类的元数据（如类名、方法、字段、注解等）并操作类对象（**构造示例、调用，方法、修改字段值**）的能力。核心是通过Class对象实现的，例如class.forName("类路径")加载类。
反射的缺点是：
（1）性能开销：反射需要动态解析类型，查找方法，即使jdk8经过专门优化，仍比直接调用慢两三倍
（2）破坏封装性：通过反射可以强制访问修改private甚至是final的方法和字段
（3）存在安全隐患：反射可以绕过安全检查，可能会被恶意代码利用
（4）维护性差：反射代码可读性低，编译器无法检查方法是否存在或者类型是否正确，容易在运行时出错
框架为什么需要反射：
（1）动态性：框架需要处理未知的类，反射允许在运行时加载并操作这些类
（2）突破语言限制：操作修改final字段，调用私有方法
（3）解耦与扩展性：框架通过反射实现插件化设计
### 11. Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符？
Java泛型允许在定义类、接口、方法时**参数化类型**（类似于方法中的形参（定义时占位）和实参（调用时传入具体值），只不过这里的“参数”是类型（如 `String`、`Integer` 等））。
将类型检查由运行时提前到编译时，避免ClassCastException。
**类型擦除**是指编译器会在编译后把泛型类型信息擦除掉，具体的动作有：
（1）无界泛型（如T）会被替换成Object，有界泛型（如T extends Number）替换为上限类Number。
（2）编译器会插入强制类型转换代码，比如
```java
List<String> list = new ArrayList<>();// 擦去<String>
list.add("Hello");
String value = list.get(0);//插入(String)list.get(0)
```
（3）生成桥方法（Bridge Method）保持多态性
当泛型类或接口被继承/实现时，由于类型擦除可能导致 ‌方法签名冲突‌，编译器会生成 ‌桥方法‌ 来维护多态性。
**常用的通配符有**：
```text
1、无界通配符<?> ：表示未知类型
2、上界通配符<? extends T>：表示类型为T的子类
3、下界通配符<? super T>：表示类型为T的父类
```
是