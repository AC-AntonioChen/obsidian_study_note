## 1 Java基础
### 1.1 Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？
short，int，long，float，double,boolean，char，byte
Short,Integer,Long,Float,Double,Boolean，Character，Byte
占用字节：
short：2byte （-2^15 至 2^15-1，即-32768 到 32767）
int :4byte（ ‌-2³¹ 到 2³¹-1‌（约±21亿））
long：8byte
float：4byte（1位符号位+8位指数位+23位尾数：尾数 * （2^指数）），约6~7位十进制
double：8byte(1+11+52)，约15~17位十进制
boolean：通常用1bit存储，但根据jvm实现有差异
char：2byte，Unicode字符，范围 \u0000 到 \uffff（0 到 65535）。
byte：1byte，-2⁷ 至 2⁷-1（-128 到 127）
### 1.2 String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?
1. ‌**String**‌：不可变字符序列，任何修改操作（如拼接）会生成新对象。适用于字符串不频繁修改的场景。
2. ‌**StringBuffer**‌：可变字符序列，线程安全（方法用`synchronized`修饰），性能较低，适用于多线程环境。
3. ‌**StringBuilder**‌：可变字符序列，线程不安全，性能较高，适用于单线程环境。

String不可变的原因是：
（1）String类本身使用了final作为修饰，使得类对象本身不可变
（2）String类中用于实际存储字符信息的char[]数组，是private final的,并且不提供修改char[]的数组的方法。
### 1.3 String s1 = new String("abc"); 这段代码创建了⼏个字符串对象？
- 若`"abc"`首次出现：创建‌**2个对象**‌（1个常量池对象 + 1个堆对象）。
- 若`"abc"`已存在常量池：创建‌**1个对象**‌（仅堆对象）。
字面量仅在‌**首次出现**‌时触发常量池对象创建
### 4. == 与 equals?hashCode 与 equals ?
```
对于基础类型，==比较值是否相等，没有equals方法
对于对象类型，==比较两个对象的地址是否相等，equals默认也是比较地址是否相等，如果重写了equals方法，就会按照equals方法的逻辑进行比较，例如对于Integer类型，equals方法被重写为比较整数数值是否相等。
```

hashCode 与 equals 有这样的强制契约:
（1）如果对象A equals 对象B，那么两个对象的hashcode必须一致，**这样才能使哈希集合正确的处理该对象类型**
（2）如果对象A和对象B的hashcode一致，那么这两个对象可以不相等，也就是允许出现哈希碰撞

hashCode 与 equals 必须同时重写。

### 5. 包装类型的缓存机制了解么？
包装类型的缓存机制如下：
（1）Integer的缓存机制是使用了一个cache， Integer类型在类加载时会执行一段往cache中存放-128到127字面量的逻辑，这样在声明值为-128到127的Integer，当使用自动装箱字面量来定义包装类型对象时，就可以直接复用cache中已有的对象。Integer的缓存上限127可通过JVM参数 `-XX:AutoBoxCacheMax` 调整（例如扩展至200）
（2）Boolean的缓存机制是在类加载时就直接把True跟False缓存起来。
（3）Short也是缓存-128到127，但不能调整缓存池上限
（4）Long也是缓存-128到127，但不能调整缓存池上限
（5）Character仅缓存0~127，刚好覆盖标准ASCII字符集
（6）Byte缓存-128到127
（7）‌**Float 和 Double 无缓存**‌：自动装箱时始终生成新对象‌

### 6. ⾃动装箱与拆箱了解吗？原理是什么？
自动装箱跟自动拆箱实际上都是编译器行为。

自动装箱是编译器将字面量转成包装类型的过程。实际上是调用valueOf方法，比如Integer a = 1；在编译后，就会变成Integer a = Integer.valueOf(1)；

自动拆箱则是编译器将包装类型转成字面量的过程，实际上是调用了XXXValue()，比如intValue()，doubleValue() ，所以当包装类型被赋值null后再自动拆箱会出现空指针问题。

频繁拆装箱会增加开销，装箱会涉及对象创建，而拆箱则需从堆内存对象中提取值并进行类型检查，可能还会涉及强制类型转换

### 7. 深拷⻉和浅拷⻉区别了解吗？什么是引⽤拷⻉？
‌**深拷贝**‌：完全复制原始对象及其所有嵌套引用的对象，生成一个完全独立的副本。
‌**浅拷贝**‌：仅复制原始对象的字段值（**基本类型直接复制，引用类型复制地址**），副本与原对象共享引用字段指向的对象。
Object.clone() 默认是浅拷贝‌，需重写 clone() 并递归处理引用字段才能实现深拷贝。
‌**引用拷贝**‌：仅创建新的引用变量指向同一对象，没有对象复制行为。例如：
User a = new User();  
User b = a;  // 引用拷贝，修改 b 会影响 a  
### 8. 谈谈对 Java 注解的理解，解决了什么问题？
Java注解Annotation是一种为代码(类，方法，参数)提供结构化元数据的增强方式，本质上是通过@interface语法定义的接口，通过编译器或者运行时框架解析。
从分类上说，注解一般有内置注解，元注解跟自定义注解。
注解主要解决的问题：
	（1）解耦配置与代码，提升代码可读性：取代传统bean的xml配置方式，通过声明式注解，如@Component直接在代码中嵌入配置信息
	（2）标准化扩展能力：为框架提供统一的扩展点。
		例如编译时可以通过@Override校验方法重写逻辑
			运行时Spring框架可以通过@Autowired实现自动注入，所以注解也常用来实现需要的aop业务逻辑如日志打印，事务管理等

### 9. Exception 和 Error 有什么区别？
Java 异常体系的根类是 **Throwable**，其直接子类为 Error 和 Exception。

‌Error‌ 表示 JVM 无法处理的严重问题（如 OutOfMemoryError），属于非受检异常，程序不应捕获。
‌Exception‌ 分为两类：
‌受检异常‌（如 IOException）：必须通过 try-catch 或 throws 显式处理。
‌非受检异常‌：即 RuntimeException 及其子类（如空指针异常），由代码逻辑错误引发，编译时不强制处理。
### 10. Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？
反射是Java在运行时动态获取类的元数据（如类名、方法、字段、注解等）并操作类对象（**构造示例、调用，方法、修改字段值**）的能力。核心是通过Class对象实现的，例如class.forName("类路径")加载类。
反射的缺点是：
（1）性能开销：反射需要动态解析类型，查找方法，即使jdk8经过专门优化，仍比直接调用慢两三倍
（2）破坏封装性：通过反射可以强制访问修改private甚至是final的方法和字段
（3）存在安全隐患：反射可以绕过安全检查，可能会被恶意代码利用
（4）维护性差：反射代码可读性低，编译器无法检查方法是否存在或者类型是否正确，容易在运行时出错
框架为什么需要反射：
（1）动态性：框架需要处理未知的类，反射允许在运行时加载并操作这些类
（2）突破语言限制：操作修改final字段，调用私有方法
（3）解耦与扩展性：框架通过反射实现插件化设计
### 11. Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符？
Java泛型允许在定义类、接口、方法时**参数化类型**（类似于方法中的形参（定义时占位）和实参（调用时传入具体值），只不过这里的“参数”是类型（如 `String`、`Integer` 等））。
将类型检查由运行时提前到编译时，避免ClassCastException。
**类型擦除**是指编译器会在编译后把泛型类型信息擦除掉，具体的动作有：
（1）无界泛型（如T）会被替换成Object，有界泛型（如T extends Number）替换为上限类Number。
（2）编译器会插入强制类型转换代码，比如
```java
List<String> list = new ArrayList<>();// 擦去<String>
list.add("Hello");
String value = list.get(0);//插入(String)list.get(0)
```
（3）生成桥方法（Bridge Method）保持多态性
‌**桥方法**‌：解决类型擦除后子类无法正确覆盖父类方法的问题。
**常用的通配符有**：
```text
1、无界通配符<?> ：表示未知类型
2、上界通配符<? extends T>：表示类型为T的子类，用于生产者场景，比如向入参集合中写入元素
3、下界通配符<? super T>：表示类型为T的父类，用于消费者场景，比如读取入参集合的元素
```

### 12. 内部类了解吗？匿名内部类了解吗？
内部类是定义在另一个类内部的类，分为四种：
1. ‌**成员内部类（非静态）**‌
    
    - 定义：直接声明在外部类中，依赖外部类实例存在（需先创建外部类对象才能实例化）。
    - 特点：可访问外部类所有成员（包括私有），但自身不能定义静态成员（常量除外）。
    - 示例：`Map.Entry` 是 `HashMap` 的成员内部类，与外部类实例状态紧密关联。
2. ‌**静态内部类**‌
    
    - 定义：用 `static` 修饰，不依赖外部类实例（可直接 `new Outer.Inner()`）。
    - 特点：只能访问外部类的静态成员，常用于工具类（如 `Collections.UnmodifiableList`）。
3. ‌**匿名内部类**‌
    
    - 定义：无显式类名，通过 `new Interface() { ... }` 或 `new AbstractClass() { ... }` 直接定义并实例化。
    - 特点：‌**不能有构造函数**‌，常用于事件监听（如 Swing 的 `ActionListener`）。与 Lambda 的区别：可覆盖**多个**方法，适用非函数式接口。
4. ‌**局部内部类**‌
    
    - 定义：在方法或作用域内定义，仅在该作用域有效。
    - 特点：‌**只能访问 final 或等效 final 的局部变量**‌，无法添加访问修饰符。示例：在方法内定义线程任务类。

### 13. BIO,NIO,AIO 有什么区别?

‌BIO（Blocking I/O）‌：同步阻塞模型，每个连接需独立线程处理读写。例如，传统Socket编程中，accept()和read()会阻塞线程直至数据就绪。适用于低并发场景（如内部管理系统），但线程数过多时易导致OOM。

‌NIO（Non-blocking I/O）‌：同步非阻塞模型，核心组件为Channel、Buffer、Selector。通过Selector轮询就绪事件（如OP_ACCEPT），单线程可管理多个连接。例如，Netty框架基于NIO实现百万级并发，适用于IM系统或API网关，但编程复杂度较高（需处理半包、粘包）。

‌AIO（Asynchronous I/O）‌：异步非阻塞模型，用户发起IO后立即返回，内核完成操作后通过回调（如CompletionHandler）通知。例如，文件异步读写可避免线程阻塞，适用于长连接场景（如股票行情推送）。但Linux对原生AIO支持有限，需注意平台兼容性。

## Java 集合框架
![image.png](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20250412222647.png)

### 1、说说 List,Set,Map 三者的区别？三者底层的数据结构？
List 存储的元素是有序的，可重复的。
Set存储 的元素是唯一的，不可重复的。
Map存储的是键值对，其中key 是无序的、不可重复的，而value是无序的，可重复的，每个key最多映射一个值。
List下有ArrayList（用Object[]数组实现，线程不安全）、Vector（用Object[]数组实现，线程安全）、LinkedList（双向链表,不能随机访问）
Set下有HashSet(元素无序，底层通过hashmap实现)、LinkedHashSet（元素有序，是HashSet的子类，底层通过LinkedHashMap实现）、TreeSet（元素有序，底层通过使用红黑树的TreeMap实现）
Map下有HashMap(jdk1.7用的数组+链表，1
8用的数组+链表/红黑树)、LinkedHashMap（继承自hashmap，增加了一条双向链表使其能保持插入时的顺序）、TreeMap（底层通过红黑树实现）跟HashTable（数组+链表，链表用于解决哈希冲突）

### 2. 有哪些集合是线程不安全的？怎么解决呢？
List中的ArrayList、LinkedList是线程不安全的，如有线程安全需要，可以替换成vector，或者对这些集合进行加锁
Set下的HashSet、Treeset、LinkedHashSet都是线程不安全的
Map下的HashMap、TreeMap、LinkedListHashMap都是线程不安全的。
一般解决方案有几种：
1、传统同步方式
（1）对使用集合的代码块进行加锁控制并发
（2）Collection.synchronizedList/Map/Set（）包装原有集合
2、JUC的并发集合类
List用 CopyOnWriteArrayList（写复制数组，写时复制，读无锁）
Set用 CopyOnWriteArraySet(基于CopyOnWriteArrayList实现，适合读多写少)
Map用ConcurrentHashMap （jdk8后用cas和synchronized，高并发性能优）
3、直接用vector或者hashTable，但是锁颗粒度大且性能差（源码的add、put方法直接用synchronized修饰了）
### 3. ⽐较 HashSet、LinkedHashSet 和 TreeSet 三者的异同
HashSet是无序的，基于HashMap，查找平均时间复杂度是O（1）
LinkedHashSet 是有序的，是hashset的子类，此外在hashset的基础上又加了一条双向列表用于维护插入顺序信息，查找平均时间复杂度也是O（1）
TreeSet是有序且基于红黑树的，基于TreeMap，元素可以按自定义ComParator排序，一般在业务需要动态排序时使用，查找平均时间复杂度是O(log n)，此外前两种set都允许元素为null，但treeset默认不允许

### 4. HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区 别？
（1）HashMap 和 Hashtable 的区别
HashMap是线程不安全的，HashTable通过synchronized实现了线程安全，但性能较低（在非静态方法上加synchronized会锁住整个实例的所有synchronized方法（本质上是锁this），而HashTable给其所有public 方法都加上了synchronized）。
hashMap允许null 键和null值，hashtable则都不允许。
HashMap的底层在jdk1.8使用了数组+红黑树/链表（链表长度大于等于8时转红黑树，红黑树长度小于等于6时退化为链表），HashTable则始终使用数组+链表。
HashTable的初始容量为11，每次扩容为2n+1（除留余数）；HashMap的初始容量为16，扩容为2n
（2）HashMap 和 HashSet 区别？
HashSet是基于HashMap实现的,新增元素直接调用hashmap的put，元素作为键，PRESENT(new Object（）)作为值。
HashSet存储唯一元素，而HashMap则是存储键值对，键唯一但值可重复。
(3)HashMap 和 TreeMap 区 别？
TreeMap基于红黑树实现，按键的自然顺序或者Comparator排序，支持有序操作（如firstKey（））,所以treemap适合需要按键排序或范围查询的场景
HashMap无序，平均操作时间复杂度为O（1）；TreeMap操作时间复杂度为O（log n）
### 5、HashMap 的底层实现

在JDK1.7及其之前，HashMap的底层实现使用的是数组+链表，当发生哈希冲突时，也就是数组上已经有元素时，新的元素会通过头插法插到链表上，在出现多个线程并发同时操作同一个索引的头插时，可能会导致链表成环，陷入死循环。在极端情况下，hashmap可能会退化成一个链表。

在jdk1.8后 hashmap底层实现使用了数组+红黑树/链表。当发生哈希冲突时，新的元素会通过尾插法插入。当链表元素长度大于等于8且数组长度大于等于64时会转红黑树，如果链表元素长度大于等于8但数组长度没有大于64则触发扩容，因为扩容的开销比树化低，而红黑树长度小于等于6时会退化回链表。

hashmap还有几个关键参数，初始容量，负载因子，最大容量。
初始容量跟负载因子都可以在构造函数中传参指定，默认的初始容量是16，负载因子是0.75，最大容量是2的三十次方（大概十亿多）。
当 当前元素个数大于等于初始容量乘以负载因子时会发生扩容。扩容是一个创建容量翻两倍的新数组，重新计算哈希值的过程。扩容翻两倍是因为hashmap计算索引每次是通过扰动后位运算进行的，保持2的幂次才能高效移位
