## 1 Java基础
### 1.1 Java 中的⼏种基本数据类型是什么？对应的包装类型是什么？各⾃占⽤多少字节呢？
short，int，long，float，double,boolean，char，byte
Short,Integer,Long,Float,Double,Boolean，Character，Byte
占用字节：
short：2byte （-2^15 至 2^15-1，即-32768 到 32767）
int :4byte（ ‌-2³¹ 到 2³¹-1‌（约±21亿））
long：8byte
float：4byte（1位符号位+8位指数位+23位尾数：尾数 * （2^指数）），约6~7位十进制
double：8byte(1+11+52)，约15~17位十进制
boolean：通常用1bit存储，但根据jvm实现有差异
char：2byte，Unicode字符，范围 \u0000 到 \uffff（0 到 65535）。
byte：1byte，-2⁷ 至 2⁷-1（-128 到 127）
### 1.2 String 、 StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?
1. ‌**String**‌：不可变字符序列，任何修改操作（如拼接）会生成新对象。适用于字符串不频繁修改的场景。
2. ‌**StringBuffer**‌：可变字符序列，线程安全（方法用`synchronized`修饰），性能较低，适用于多线程环境。
3. ‌**StringBuilder**‌：可变字符序列，线程不安全，性能较高，适用于单线程环境。

String不可变的原因是：
（1）String类本身使用了final作为修饰，使得类对象本身不可变
（2）String类中用于实际存储字符信息的char[]数组，是private final的,并且不提供修改char[]的数组的方法。
### 1.3 String s1 = new String("abc"); 这段代码创建了⼏个字符串对象？
- 若`"abc"`首次出现：创建‌**2个对象**‌（1个常量池对象 + 1个堆对象）。
- 若`"abc"`已存在常量池：创建‌**1个对象**‌（仅堆对象）。
字面量仅在‌**首次出现**‌时触发常量池对象创建
### 4. == 与 equals?hashCode 与 equals ?
```
对于基础类型，==比较值是否相等，没有equals方法
对于对象类型，==比较两个对象的地址是否相等，equals默认也是比较地址是否相等，如果重写了equals方法，就会按照equals方法的逻辑进行比较，例如对于Integer类型，equals方法被重写为比较整数数值是否相等。
```

hashCode 与 equals 有这样的强制契约:
（1）如果对象A equals 对象B，那么两个对象的hashcode必须一致，**这样才能使哈希集合正确的处理该对象类型**
（2）如果对象A和对象B的hashcode一致，那么这两个对象可以不相等，也就是允许出现哈希碰撞

hashCode 与 equals 必须同时重写。

### 5. 包装类型的缓存机制了解么？
包装类型的缓存机制如下：
（1）Integer的缓存机制是使用了一个cache， Integer类型在类加载时会执行一段往cache中存放-128到127字面量的逻辑，这样在声明值为-128到127的Integer，当使用自动装箱字面量来定义包装类型对象时，就可以直接复用cache中已有的对象。Integer的缓存上限127可通过JVM参数 `-XX:AutoBoxCacheMax` 调整（例如扩展至200）
（2）Boolean的缓存机制是在类加载时就直接把True跟False缓存起来。
（3）Short也是缓存-128到127，但不能调整缓存池上限
（4）Long也是缓存-128到127，但不能调整缓存池上限
（5）Character仅缓存0~127，刚好覆盖标准ASCII字符集
（6）Byte缓存-128到127
（7）‌**Float 和 Double 无缓存**‌：自动装箱时始终生成新对象‌

### 6. ⾃动装箱与拆箱了解吗？原理是什么？
自动装箱跟自动拆箱实际上都是编译器行为。

自动装箱是编译器将字面量转成包装类型的过程。实际上是调用valueOf方法，比如Integer a = 1；在编译后，就会变成Integer a = Integer.valueOf(1)；

自动拆箱则是编译器将包装类型转成字面量的过程，实际上是调用了XXXValue()，比如intValue()，doubleValue() ，所以当包装类型被赋值null后再自动拆箱会出现空指针问题。

频繁拆装箱会增加开销