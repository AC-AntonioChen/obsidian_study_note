## 1 基础
### 什么是线程和进程?线程与进程的关系,区别及优缺点？⭐⭐⭐⭐
进程：是操作系统分配资源的基本单位，拥有独立的地址空间（代码、数据、堆栈等），进程间隔离性强。
线程：是CPU调度的最小单位，属于进程的一部分。多个线程共享进程的内存和资源（如文件句柄）。
线程与进程：一个进程至少有一个主线程，线程是进程内的**执行单元**
区别：
（1）资源分配：进程拥有独立的地址空间，其他进程不能随便访问。线程则共享进程的内存。
（2）切换开销：进程切换开销大，涉及切换内存映射，寄存器。线程切换只需要切换寄存器等少量状态。
（3）通信方式：进程间需通过IPC（如管道、socket）做通信，而线程可直接读写共享内存。
（4）容错性：进程崩溃不影响其他进程，而线程崩溃可能会让其进程一并崩溃。
进程的优点是隔离性好、稳定性高，缺点是资源开销大、调试复杂。
线程的优点是轻量高效、通信简单。缺点是需同步处理问题，调试复杂
### 为什么要使用多线程呢? ⭐⭐⭐
（1）提升性能：通过并行利用多核cpu资源，加快计算密集型任务处理速度
（2）提高响应性：例如在GUI应用中，由后台线程处理耗时操作，避免主线程阻塞导致页面卡顿
（3）高吞吐场景：多线程可以同时处理多个用户的请求，提升系统吞吐量
（4）简化复杂任务模型：方便把大任务拆成小任务并行执行，如分治算法
（5）异步处理：处理非阻塞IO操作，避免等待浪费cpu周期
### 说说线程的生命周期和状态? ⭐⭐⭐⭐
java线程有六种标准状态：
new、runnable、blocked‌、waiting、timed_waiting、terminated
（1）new是创建态，当线程被new()创建但还未start()时处于此状态，此时操作系统还没有真正创建线程
（2）调用start后线程进入runnable就绪运行态，java的runnable状态包括了操作系统的就绪态和运行态，具体的状态取决于OS的线程调度器决定是否分配CPU时间片
（3）blocked是阻塞态，当线程因竞争`synchronized` 锁失败被阻塞，线程会暂停执行，jvm锁监视器机制将线程挂起，等到线程竞争的锁释放后，jvm会自动唤醒该线程去继续竞争锁。
```quote
`BLOCKED` 状态是 `synchronized` 锁竞争失败的专属状态，其他锁（如 `ReentrantLock`）的竞争失败不会触发此状态
```


（4）waiting是等待态，当线程主动的Obejct.wait()或者Thread.join()等无限期等待方法时进入此状态，需要其他线程去显式唤醒。
（5）timed_waiting是超时等待态，当使用有超时参数的等待方法时，进入此状态，到了超时时间，jvm会将其置为runnable状态
（6）**TERMINATED**‌是终止态，当线程正常执行结束或者线程异常终止时进入此状态， 操作系统也会释放线程的资源

 操作系统一般是五种状态：
 创建态、就绪态、运行态、阻塞态、终止态
 

### 什么是线程死锁?如何避免死锁?如何预防和避免线程死锁? ⭐⭐⭐⭐
死锁：多个线程因为竞争资源陷入了互相等待的状态，每个线程都持有了对方需要的资源却不释放时，导致程序卡住。
死锁只有**同时满足**以下四个条件才会发生：
（1）互斥条件:指**多个线程不能同时使用同一个资源**。
（2）持有并等待条件：一个线程因请求资源而阻塞时，也不释放已获得的资源。
（3）不剥夺：当线程已经持有了资源 ，**在自己使用完之前不能被其他线程获取**。
（4）环路等待：两个线程获取资源的顺序构成了环形链,也就是说线程1已经持有了资源1需要资源2，而线程2已经持有了资源2又需要资源1。
避免死锁问题就只需要破环其中一个条件就可以：
（1）业务上用的比较多的是破坏环路等待，也就是为资源定义全局顺序，所有线程获取资源的顺序都是一样，比如所有线程按顺序获取资源1、2、3
（2）也可以持有并等待条件，Lock.tryLock(timeout)为线程设置超时等待时间，超时后自动释放已有锁并重试
（3）另外一种破坏持有并等待条件：线程必须一次性获得其所需要的所有的资源，否则就释放自己的所有资源
（4）预防死锁一般使用银行家算法：仅在资源分配后系统仍处于安全状态时允许分配。
## 2 乐观锁和悲观锁
### 乐观锁和悲观锁的区别 ⭐⭐⭐⭐⭐
简单来说，乐观锁通过无锁+重试解决冲突，而悲观锁预防冲突。
具体来说，乐观锁假设冲突极少发生，操作数据时不加锁，提交更新时数据前会检查一次版本号或者做一次CAS来校验数据，如果冲突，那么再重试整个操作。比如AtomicInteger就是基于cas做的
悲观锁假设冲突总是发生，在操作数据时就会加锁，确保独占访问，比如synchronized、Reentrantlock
乐观锁适合读多写少，减少锁竞争开销。
而悲观锁适合读少写多的情况，避免频繁重试导致性能下降。
### 如何实现乐观锁？ ⭐⭐⭐⭐
乐观锁一般有以下两种实现方式
（1）数据库场景的版本号机制实现：在数据库的表中添加version字段，每次读取数据时保存当前版本号x，在提交更新时校验并递增版本号(在where条件中加上version=x)，若影响行数为0则说明冲突发生，需要重试
（2）基于CAS原子操作实现
cas也就是比较并交换，在硬件层面使用硬件指令（如cpu的cmpxchg），在java代码中，则是用封装了cas功能的atomic类与dowhile循环实现不断重试cas直到成功

### CAS 了解么？原理？ ⭐⭐⭐⭐⭐
cas是compare and swap 比较并交换，是基于CPU提供的一种原子操作，cmpxchg指令，指令有三个操作数，分别是内存位置V，预期原值A，新值B。当内存位置的值与预期原值一致时，将V更新为新值B，否则则放弃操作。
在java中，atomic类里通过unsafe封装了cas，我们常用的atomicInteger().incrementAndGet()等方法都使用到了cas
### 乐观锁存在哪些问题？ ⭐⭐⭐
（1）存在ABA问题，cas的原理是cpmxchg cpu指令，有三个操作数，内存位置V 预期原值A 
（2）在高并发场景下或者写密集型场景下，数据冲突会经常出现，这时候乐观锁带来的反复重试的开销会很大
### 什么是 ABA 问题？ABA 问题怎么解决？ ⭐⭐⭐⭐
## 3 JMM
### 并发编程的三个重要特性 ⭐⭐⭐⭐⭐
### 什么是 JMM？为什么需要 JMM？ ⭐⭐⭐⭐⭐
### JMM 是如何抽象线程和主内存之间的关系？⭐⭐⭐⭐⭐
### Java 内存区域和 JMM 有何区别？ ⭐⭐⭐⭐
### happens-before 原则是什么？为什么需要 happens-before 原则？ ⭐⭐⭐
## 4 synchronized 和 volatile
### synchronized 关键字 ⭐⭐⭐⭐⭐
### volatile 关键字 ⭐⭐⭐⭐⭐
## 5 ThreadLocal
### ThreadLocal 有什么用？⭐⭐⭐
### ThreadLocal 原理了解吗？⭐⭐⭐⭐⭐
## 6 线程池
### 为什么要用线程池？⭐⭐⭐⭐
### 为什么不推荐使用内置线程池？⭐⭐⭐⭐⭐
### 线程池常见参数有哪些？如何解释？⭐⭐⭐⭐⭐
### 线程池的拒绝策略有哪些？⭐⭐⭐⭐⭐
### 线程池的核心线程会被回收吗？⭐⭐⭐
### 线程池常用的阻塞队列有哪些？⭐⭐⭐
### 线程池处理任务的流程了解吗？⭐⭐⭐⭐⭐
### 线程池中线程异常后，销毁还是复用？⭐⭐⭐⭐
### 如何设计一个能够根据任务的优先级来执行的线程池？⭐⭐⭐⭐
## 7 AQS
### AQS 是什么？AQS 的原理是什么？⭐⭐⭐⭐⭐
### Semaphore 有什么用？Semaphore 的原理是什么？⭐⭐⭐⭐
### CountDownLatch 有什么用？CountDownLatch 的原理是什么？用过 CountDownLatch 么？什么场景下用的？⭐⭐⭐⭐
### CyclicBarrier 有什么用？CyclicBarrier 的原理是什么