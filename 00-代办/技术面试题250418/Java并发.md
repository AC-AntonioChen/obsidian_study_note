## 1 基础
### 1.1 什么是线程和进程?线程与进程的关系,区别及优缺点？⭐⭐⭐⭐
进程：是操作系统分配资源的基本单位，拥有独立的地址空间（代码、数据、堆栈等），进程间隔离性强。
线程：是CPU调度的最小单位，属于进程的一部分。多个线程共享进程的内存和资源（如文件句柄）。
线程与进程：一个进程至少有一个主线程，线程是进程内的**执行单元**
区别：
（1）资源分配：进程拥有独立的地址空间，其他进程不能随便访问。线程则共享进程的内存。
（2）切换开销：进程切换开销大，涉及切换内存映射，寄存器。线程切换只需要切换寄存器等少量状态。
（3）通信方式：进程间需通过IPC（如管道、socket）做通信，而线程可直接读写共享内存。
（4）容错性：进程崩溃不影响其他进程，而线程崩溃可能会让其进程一并崩溃。
进程的优点是隔离性好、稳定性高，缺点是资源开销大、调试复杂。
线程的优点是轻量高效、通信简单。缺点是需同步处理问题，调试复杂
### 1.2 为什么要使用多线程呢? ⭐⭐⭐
（1）提升性能：通过并行利用多核cpu资源，加快计算密集型任务处理速度
（2）提高响应性：例如在GUI应用中，由后台线程处理耗时操作，避免主线程阻塞导致页面卡顿
（3）高吞吐场景：多线程可以同时处理多个用户的请求，提升系统吞吐量
（4）简化复杂任务模型：方便把大任务拆成小任务并行执行，如分治算法
（5）异步处理：处理非阻塞IO操作，避免等待浪费cpu周期
### 1.3 说说线程的生命周期和状态? ⭐⭐⭐⭐
java线程有六种标准状态：
new、runnable、blocked‌、waiting、timed_waiting、terminated
![image.png](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20250429220526.png)

（1）new是创建态，当线程被new()创建但还未start()时处于此状态，此时操作系统还没有真正创建线程
（2）调用start后线程进入runnable就绪运行态，java的runnable状态包括了操作系统的就绪态和运行态，具体的状态取决于OS的线程调度器决定是否分配CPU时间片
（3）blocked是阻塞态，当线程因竞争`synchronized` 锁失败被阻塞，线程会暂停执行，jvm锁监视器机制将线程挂起，等到线程竞争的锁释放后，jvm会自动唤醒该线程去继续竞争锁。
```quote
`BLOCKED` 状态是 `synchronized` 锁竞争失败的专属状态，其他锁（如 `ReentrantLock`）的竞争失败不会触发此状态
```


（4）waiting是等待态，当线程主动的Obejct.wait()或者Thread.join()等无限期等待方法时进入此状态，需要其他线程去显式唤醒。
（5）timed_waiting是超时等待态，当使用有超时参数的等待方法时，进入此状态，到了超时时间，jvm会将其置为runnable状态
（6）**TERMINATED**‌是终止态，当线程正常执行结束或者线程异常终止时进入此状态， 操作系统也会释放线程的资源

 操作系统一般是五种状态：
 创建态、就绪态、运行态、阻塞态、终止态
 ![image.png](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20250429220824.png)
 - **New**（创建状态）
    - 当线程对象被创建但尚未启动时，线程处于新建状态。
    - 在这个阶段，操作系统正在为线程分配必要的资源，并进行初始化设置。
- **Ready**（就绪状态）
    - 在线程被创建并准备好执行时，它进入就绪状态。
    - 就绪状态表示线程已经准备好运行，等待被分配到CPU时间片进行执行。
    - 在多线程环境中，多个就绪状态的线程可能会竞争CPU资源。
- **Running**（执行状态）
    - 当线程被调度并获得CPU时间片时，它进入执行状态。
    - 执行状态表示线程正在执行其指定的任务或代码。
    - 在单核处理器系统中，同一时刻只能有一个线程处于执行状态。在多核处理器系统中，多个线程可以同时处于执行状态。
- **Blocked**（阻塞状态）
    - 当线程等待某些条件满足时，无法继续执行时，它进入阻塞状态。
    - 阻塞状态表示线程被阻塞，暂时停止执行，并且不会占用CPU资源。
    - 常见的阻塞原因包括等待I/O操作完成、等待锁、等待其他线程的通知等。
- **Terminated**（终止状态）
    - 当线程执行完其任务、显式终止或出现异常而无法继续执行时，它进入终止状态。
    - 在终止状态下，线程已经完成了它的生命周期，并且不再执行。




### 1.4 什么是线程死锁?如何避免死锁?如何预防和避免线程死锁? ⭐⭐⭐⭐
死锁：多个线程因为竞争资源陷入了互相等待的状态，每个线程都持有了对方需要的资源却不释放时，导致程序卡住。
死锁只有**同时满足**以下四个条件才会发生：
（1）互斥条件:指**多个线程不能同时使用同一个资源**。
（2）持有并等待条件：一个线程因请求资源而阻塞时，也不释放已获得的资源。
（3）不剥夺：当线程已经持有了资源 ，**在自己使用完之前不能被其他线程获取**。
（4）环路等待：两个线程获取资源的顺序构成了环形链,也就是说线程1已经持有了资源1需要资源2，而线程2已经持有了资源2又需要资源1。
避免死锁问题就只需要破环其中一个条件就可以：
（1）业务上用的比较多的是破坏环路等待，也就是为资源定义全局顺序，所有线程获取资源的顺序都是一样，比如所有线程按顺序获取资源1、2、3
（2）也可以持有并等待条件，Lock.tryLock(timeout)为线程设置超时等待时间，超时后自动释放已有锁并重试
（3）另外一种破坏持有并等待条件：线程必须一次性获得其所需要的所有的资源，否则就释放自己的所有资源
（4）预防死锁一般使用银行家算法：仅在资源分配后系统仍处于安全状态时允许分配。
## 2 乐观锁和悲观锁
### 2.1 乐观锁和悲观锁的区别 ⭐⭐⭐⭐⭐
简单来说，乐观锁通过无锁+重试解决冲突，而悲观锁预防冲突。
具体来说，乐观锁假设冲突极少发生，操作数据时不加锁，提交更新时数据前会检查一次版本号或者做一次CAS来校验数据，如果冲突，那么再重试整个操作。比如AtomicInteger就是基于cas做的
悲观锁假设冲突总是发生，在操作数据时就会加锁，确保独占访问，比如synchronized、Reentrantlock
乐观锁适合读多写少，减少锁竞争开销。
而悲观锁适合读少写多的情况，避免频繁重试导致性能下降。
### 2.2 如何实现乐观锁？ ⭐⭐⭐⭐
乐观锁一般有以下两种实现方式
（1）数据库场景的版本号机制实现：在数据库的表中添加version字段，每次读取数据时保存当前版本号x，在提交更新时校验并递增版本号(在where条件中加上version=x)，若影响行数为0则说明冲突发生，需要重试
（2）基于CAS原子操作实现
cas也就是比较并交换，在硬件层面使用硬件指令（如cpu的cmpxchg），在java代码中，则是用封装了cas功能的atomic类与dowhile循环实现不断重试cas直到成功

### 2.3 CAS 了解么？原理？ ⭐⭐⭐⭐⭐
cas是compare and swap 比较并交换，是基于CPU提供的一种原子操作，cmpxchg指令，指令有三个操作数，分别是内存位置V，预期原值A，新值B。当内存位置的值与预期原值一致时，将V更新为新值B，否则则放弃操作。
在java中，atomic类里通过unsafe封装了cas，我们常用的atomicInteger().incrementAndGet()等方法都使用到了cas
### 2.4 乐观锁存在哪些问题？ ⭐⭐⭐
（1）存在ABA问题，cas的原理是cpmxchg cpu指令，有三个操作数，内存位置V 预期原值A 新值B，如果线程1已经读取了内存位置的值但还未更新值前，有其他线程将该位置的值由A置为其他数值又置为A，那么等到线程1 发出cas指令时，cpu仍会执行该操作，但线程1不知道值已经被操作过了
（2）在高并发场景下或者写密集型场景下，数据冲突会经常出现，这时候乐观锁带来的反复重试的开销会很大
### 2.5 什么是 ABA 问题？ABA 问题怎么解决？ ⭐⭐⭐⭐
ABA问题是cas的一个逻辑缺陷，cas的原理是cpmxchg cpu指令，有三个操作数，内存位置V 预期原值A 新值B，如果线程1已经读取了内存位置的值但还未更新值前，有其他线程将该位置的值由A置为其他数值又置为A，那么等到线程1 发出cas指令时，cpu仍会执行该操作，但线程1不知道值已经被操作过了。
ABA问题可以通过加一个版本号来解决，在值和版本号捆绑成一个对象，也就是我们在java里使用的AtomicStampedReference 
## 3 JMM
### 3.1 并发编程的三个重要特性 ⭐⭐⭐⭐⭐
原子性，可见性，有序性。
（1）原子性指一个或多个操作要么全部执行且不会被中断，要么完全不执行。
常见的非原子操作有i++（读、加、写），多线程执行时会导致结果不一致。
常见的原子性保障方案有synchronized关键字或者Lock锁，能够保障代码块或者方法的原子性。
原子类（如AtomicInteger)：通过cas实现无锁的原子操作
（2）可见性是指一个线程对共享变量的修改立刻能被其他线程看到。
问题：线程可能从线程工作内存中读取了过期的共享。例如，线程A修改了标志变量后，线程B因为没有及时刷新缓存而陷入死循环。
解决方案：volatile关键字可以强制变量的读写必须与主内存交互，并禁用指令重排序。
‌synchronized 或 Lock‌：在释放锁前jvm会自动将变量同步到主内存，加锁时重新读取。
（3）有序性是指程序执行的顺序按照代码的先后顺序执行，需避免指令重排序导致意外结果。
### 3.2 什么是 JMM？为什么需要 JMM？ ⭐⭐⭐⭐⭐
#### 3.2.1 什么是JMM
JMM是java内存模型（java memory model ），是Java 定义的并发编程相关的一组**规范**，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，它规定了以下内容：
（1）内存可见性：确保一个线程对共享变量的修改能够被其他线程及时感知。
（2）原子性：定义哪些操作是不可分割的，如基本类型的读写。
（3）有序性：限制编译器和处理器的指令重排序优化，保证代码执行顺序符合预期。
JMM通过抽象主内存（共享内存：堆内存+方法区）和工作内存（本地内存）的交互模型，定义了线程间通信的规则。（如synchronized、volatile、final等关键字的行为）
#### 3.2.2 为什么需要JMM
JMM的核心目的是定义规范来解决并发编程中的问题
（1）‌跨平台性，屏蔽硬件差异：不同CPU架构的内存模型差异较大（如缓存一致性、指令重排序策略）。JMM通过统一的规则，隐藏底层复杂性，使Java程序在不同平台表现一致。
（2）抽象了happens-before原则来解决指令重排序问题
（3）‌简化多线程编程，增强程序可移植性
#### 3.2.3 什么是指令重排序？ 
简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。
常见的指令重排序有下面 2 种情况：
**编译器优化重排**：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
**指令并行重排**：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

### 3.3 JMM 是如何抽象线程和主内存之间的关系？⭐⭐⭐⭐⭐
JMM通过定义‌主内存（Main Memory）‌与‌线程工作内存（Thread Working Memory）‌的交互规则，抽象了多线程环境下内存访问的可见性、有序性和原子性问题。
主内存：所有共享变量的存储区域，对所有线程可见。
‌线程工作内存‌：每个线程独立拥有的私有内存区域，缓存主内存中的共享变量副本。
线程对变量的操作（读/写）均在工作内存中进行，而非直接操作主内存。如果线程间需要通信，必须通过主内存来进行。
![image.png](https://picgo-1324195593.cos.ap-guangzhou.myqcloud.com/picgo/20250505002759.png)


### 3.4   Java 内存区域和 JMM 有何区别？ ⭐⭐⭐⭐
Java内存区域和JMM是完全不同的概念，Java内存区域是指JVM的内存区域划分，是
### 3.5 happens-before 原则是什么？为什么需要 happens-before 原则？ ⭐⭐⭐

## 4 synchronized 和 volatile
### 4.1 synchronized 关键字 ⭐⭐⭐⭐⭐
### 4.2 volatile 关键字 ⭐⭐⭐⭐⭐
## 5 ThreadLocal
### 5.1 ThreadLocal 有什么用？⭐⭐⭐
### 5.2 ThreadLocal 原理了解吗？⭐⭐⭐⭐⭐
## 6 线程池
### 6.1 为什么要用线程池？⭐⭐⭐⭐
### 6.2 为什么不推荐使用内置线程池？⭐⭐⭐⭐⭐
### 6.3 线程池常见参数有哪些？如何解释？⭐⭐⭐⭐⭐
### 6.4 线程池的拒绝策略有哪些？⭐⭐⭐⭐⭐
### 6.5 线程池的核心线程会被回收吗？⭐⭐⭐
### 6.6 线程池常用的阻塞队列有哪些？⭐⭐⭐
### 6.7 线程池处理任务的流程了解吗？⭐⭐⭐⭐⭐
### 6.8 线程池中线程异常后，销毁还是复用？⭐⭐⭐⭐
### 6.9 如何设计一个能够根据任务的优先级来执行的线程池？⭐⭐⭐⭐
## 7 AQS
### 7.1 AQS 是什么？AQS 的原理是什么？⭐⭐⭐⭐⭐
### 7.2 Semaphore 有什么用？Semaphore 的原理是什么？⭐⭐⭐⭐
### 7.3 CountDownLatch 有什么用？CountDownLatch 的原理是什么？用过 CountDownLatch 么？什么场景下用的？⭐⭐⭐⭐
### 7.4 CyclicBarrier 有什么用？CyclicBarrier 的原理是什么