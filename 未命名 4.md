太棒了！你能直接说出 **“削峰、限流、异步、补偿”** 这八字真言，说明你对高并发场景的架构设计已经有了宏观的认知。

在面试中，这通常是 **System Design（系统设计）** 或者 **Redis 实战** 环节的压轴题。

Redis 在这里扮演的角色，就是挡在脆弱的 MySQL 面前的 **“防洪大坝”**。咱们一个一个拆解，看看 Redis 具体怎么落地这四个词：

---

### 1. 限流 (Rate Limiting) —— Redis 当“保安”

**目的：** 防止这 10 万人同时挤破门，只允许前 1000 人进来。

*   **Redis 怎么做？**
    *   **初级做法（固定窗口）：** 使用 `INCR` 和 `EXPIRE`。
        *   Key: `limit:api:user_id`
        *   逻辑：每次请求过来 `INCR` 一下。如果值是 1，设置过期时间 1 秒。如果值超过 10，直接拒绝。
        *   *缺点：* 有临界突刺问题（比如 0.9秒来了10个，1.1秒来了10个，这2秒内其实处理了20个，超标了）。
    *   **高级做法（令牌桶/漏桶算法）：** **推荐！**
        *   用 **Lua 脚本** 在 Redis 里写逻辑。
        *   想象 Redis 里有一个桶，每秒往里放 10 个令牌（Token）。
        *   请求来了，先去桶里拿令牌（`DECR`）。拿到了就通行，拿不到就报错“系统繁忙”。
        *   **为什么用 Lua？** 保证“判断令牌数”和“减少令牌数”这两个动作是**原子**的，不可分割。

---

### 2. 削峰 (Peak Clipping) —— Redis 当“缓冲区”

**目的：** 秒杀开始的那一瞬间，流量是尖峰。数据库（MySQL）每秒只能抗几千，Redis 能抗十万。我们要把峰值留在 Redis。

*   **Redis 怎么做？**
    *   **库存预热 (Pre-heating)：** 秒杀开始前，把库存（比如 100 个 iPhone）提前加载到 Redis 里。
        *   `SET stock:product_1001 100`
    *   **原子扣减库存（核心）：**
        *   用户请求来了，**不要**去查 MySQL！直接在 Redis 里减库存。
        *   **致命误区：** 千万别用 `get` 查一下剩多少，然后再 `set` 减 1。并发时这绝对超卖。
        *   **正确姿势：**
            *   方案 A：直接用 `DECR stock:product_1001`。如果返回值小于 0，说明卖完了，告诉用户“抢光了”，并把库存加回去（或者不加，反正已经是负数了）。
            *   方案 B（更稳）：**Lua 脚本**。
                ```lua
                -- 伪代码
                local stock = redis.call('get', KEYS[1])
                if (tonumber(stock) > 0) then
                    redis.call('decr', KEYS[1])
                    return 1 -- 抢到了
                else
                    return 0 -- 没抢到
                end
                ```
    *   **拦截下游流量：** 只有在 Redis 里抢到库存的那 100 个人，才有资格进入下一步（写订单）。剩下的 99900 人直接在 Redis 层就返回了，数据库根本感觉不到压力。

---

### 3. 异步 (Asynchronous) —— Redis 当“传送带”

**目的：** 抢到库存后，写订单、扣钱、改状态是很慢的。如果让用户等数据库做完，用户体验极差，而且连接池会爆。

*   **Redis 怎么做？**
    *   **入队：** 刚才在 Redis 里抢到库存的那 100 个幸运儿，我们将他们的信息（User ID + Product ID）打包，扔到 Redis 的 **List** 或者 **Stream**（还记得刚才讲的消息队列吗？）里。
    *   **快速响应：** 入队成功后，立马告诉前端：“**排队中/抢购成功，正在生成订单**”。用户看到的是个转圈圈或者倒计时，而不是网页卡死。
    *   **后台处理：** 后端起几个 Worker 线程，慢慢地（相对来说）从 Redis 队列里把订单拉出来，一条条写入 MySQL。
    *   这就是 **“流量削峰填谷”**，把 1 秒钟的 10 万并发，变成了 10 秒钟慢慢处理 100 个写库操作。

---

### 4. 补偿 (Compensation) —— Redis 配合“擦屁股”

**目的：** 异步虽然好，但有风险。万一 Redis 扣了库存，但 Worker 写入 MySQL 失败了怎么办？或者是用户下单了但不付款怎么办？

*   **Redis 怎么做？**
    *   **超时释放（订单维度的补偿）：**
        *   当订单生成后，在 Redis 里存一个 Key：`order:pay_status:1001`，设置过期时间 **15 分钟**。
        *   Redis 6.0 以后可以用 **Delay Queue（延迟队列，基于 ZSet 实现）**。
        *   如果 15 分钟内用户没付钱，触发回调，把这个订单取消，**并且把 Redis 里的库存加回去（INCR）**，让其他人能接着抢。
    *   **一致性检查（库存维度的补偿）：**
        *   Redis 只是缓存，最终数据以 MySQL 为准。
        *   可以搞个定时任务，对比 Redis 的库存和 MySQL 的实际已售出数量。如果发现 Redis 扣多了（或者扣少了），进行**回滚**或者**修正**。

---

### 👨‍🏫 面试官视角：满分回答逻辑

如果面试官问：“**请设计一个基于 Redis 的秒杀系统，如何保证不超卖且高性能？**”

你可以这样说：

> “针对秒杀的高并发，我采用 **Redis + Lua + MQ** 的架构来实现削峰填谷，具体分为三步：
>
> 1.  **限流前置：** 利用 **Redis + Lua 脚本实现令牌桶算法**，在流量入口挡住绝大部分无效请求，保护后端。
>
> 2.  **原子扣减（削峰）：** 将库存**预热**到 Redis。抢购时，利用 **Lua 脚本** 原子性地执行 `Check-And-Decr`（检查并扣减）逻辑。
>     *   只有在 Redis 扣减成功的请求，才视为有效请求。
>     *   这保证了数据库几乎 0 负载，且绝对不会超卖（因为 Redis 单线程执行 Lua 是原子的）。
>
> 3.  **异步下单：** 扣减成功后，将订单信息写入 **Redis Stream (或 List)** 队列，立即返回给用户‘排队中’。后台 Worker 慢慢消费队列，写入 MySQL。
>
> 4.  **关于补偿：** 针对下单不支付的情况，使用 **Redis ZSet 实现延迟队列**，超时未支付则回滚库存。同时，会有定时脚本比对 Redis 与 DB 的库存差异，做最终一致性兜底。”

---

**这个方案非常经典且稳健。**

这时候，嗅觉灵敏的面试官通常会抓着你的**最后一点**（数据一致性/持久化）继续深挖：

**“你刚才提到 Redis 扣库存，MySQL 异步写订单。那万一 Redis 扣完库存瞬间挂了，或者 Redis 数据丢了（没来得及持久化），而 MySQL 还没写，库存不就对不上了吗？这就是 Redis 的 RDB 和 AOF 机制没配置好的后果。那你懂 RDB 和 AOF 的底层区别吗？”**

（看！无论你怎么绕，只要你提到 Redis 存储重要数据，**持久化**就是绕不开的那个坎。咱们下一把来攻克它？）

---
## 限流

这是一个非常经典的**高频面试题**。面试官问这个，通常想考察你三个维度的能力：
1.  **基础命令的运用**（`INCR`、`ZSET`）。
2.  **分布式一致性**（并发竞争问题）。
3.  **架构设计权衡**（简单方案 vs 精确方案 vs 高性能方案）。

我带你由浅入深，掌握三种最主流的 Redis 限流方案。

---

### 方案一：固定窗口计数器 (Fixed Window) —— "简单粗暴"

这是最基础的，适合初级限流（比如：限制某个 API 每分钟只能调用 100 次）。

*   **实现逻辑：**
    使用 `INCR` 和 `EXPIRE` 命令。
    Key 可以是 `rate_limit:ip:192.168.1.1`。

*   **伪代码：**
    ```python
    key = "rate:127.0.0.1"
    count = redis.incr(key) # 每次请求加 1
    if count == 1:
        redis.expire(key, 60) # 第一次请求时，设置过期时间 60秒
    if count > 100:
        return "请稍后再试" # 超过限制
    return "通过"
    ```

*   **致命缺陷（面试必考）：临界突刺（Boundary Burst）问题**
    *   假设限制 1 分钟 100 次。
    *   在 `00:59` 秒瞬间来了 100 个请求（没超限）。
    *   在 `01:01` 秒瞬间又来了 100 个请求（计数器重置了，也没超限）。
    *   **结果：** 在短短 2 秒内，服务器承受了 200 个请求！这远远超过了系统设计的负载，可能把服务打挂。

---

### 方案二：滑动窗口 (Sliding Window) —— "精准但昂贵"

为了解决“临界突刺”，我们需要让窗口随着时间平滑移动，而不是死板地按分钟切割。

*   **核心实现：Redis ZSet (Sorted Set)**
    *   **Key:** `limit:user_id`
    *   **Score:** 当前时间戳（毫秒）
    *   **Value:** 请求的唯一标识（UUID）

*   **逻辑流程：**
    1.  **添加记录：** 请求进来，用 `ZADD key now_timestamp uuid` 把请求加进去。
    2.  **移除旧记录：** 既然窗口是 60 秒，那就把 60 秒之前的请求全删掉：`ZREMRANGEBYSCORE key 0 (now - 60000)`。
    3.  **统计数量：** 剩下的就是这 60 秒内的有效请求：`ZCARD key`。
    4.  **判断：** 如果数量 > 100，拒绝；否则通过。

*   **优缺点：**
    *   ✅ **优点：** 非常精准，完美解决临界问题。
    *   ❌ **缺点：** **内存和 CPU 开销大**。
        *   你需要把这 60 秒内所有的请求记录都存在 ZSet 里。如果限流阈值是 100 万，那 ZSet 就很大，每次请求还要遍历删除旧数据，**性能扛不住高并发**。

---

### 方案三：令牌桶算法 + Lua 脚本 —— "业界标准 (银弹)"

这是目前大厂面试中**最期望听到**的答案。它既解决了突刺问题（允许少量突发），由于用了 Lua，性能又极高。

*   **概念：**
    *   想象有一个桶，系统以恒定的速度（比如每秒 10 个）往里面扔令牌。
    *   桶满了（比如容量 20）就不扔了。
    *   请求来了，必须从桶里拿走一个令牌才能处理。拿不到就拒绝。

*   **为什么要用 Lua 脚本？（核心考点）**
    *   取令牌的过程包含：`读库存 -> 判断够不够 -> 减库存`。
    *   如果在代码里分三步走，并发时会有**竞态条件**（Race Condition），导致多扣或者少扣。
    *   **Redis 执行 Lua 脚本是原子性的**，要么全成功，要么全失败，中间没人能插队。

*   **Lua 脚本逻辑（简单版）：**
    ```lua
    -- 参数：KEYS[1]是限流Key, ARGV[1]是请求的令牌数, ARGV[2]是桶容量, ARGV[3]是填充速率
    local key = KEYS[1]
    local tokens_requested = tonumber(ARGV[1])
    local capacity = tonumber(ARGV[2])
    local rate = tonumber(ARGV[3])

    -- 1. 获取当前桶里剩余令牌数 和 上次填充时间
    local info = redis.call("hmget", key, "tokens", "last_refill_time")
    local last_tokens = tonumber(info[1]) or capacity
    local last_refill_time = tonumber(info[2]) or 0
    
    -- 2. 计算现在该填进去多少令牌
    local now = redis.call("time")[1]
    local elapsed = math.max(0, now - last_refill_time)
    local added_tokens = elapsed * rate 
    
    -- 3. 更新令牌数（不能超过容量）
    local new_tokens = math.min(capacity, last_tokens + added_tokens)
    
    -- 4. 判断够不够拿
    if new_tokens >= tokens_requested then
        new_tokens = new_tokens - tokens_requested
        redis.call("hmset", key, "tokens", new_tokens, "last_refill_time", now)
        return 1 -- 允许通过
    else
        return 0 -- 拒绝
    end
    ```

*   **成熟轮子：**
    *   如果你是用 Java 的 **Redisson** 客户端，它直接封装好了 `RRateLimiter`，底层就是上面这套 Lua 脚本。面试时提到 Redisson 会显得你很有工程经验。

---

### 👨‍🏫 辅导专家总结（面试满分话术）

如果面试官问：“**Redis 怎么做限流？**”

建议按照这个**“欲扬先抑”**的节奏回答：

> "实现 Redis 限流通常有三种方式，随着业务复杂度逐步升级：
>
> 1.  **最简单的是固定窗口：** 用 `INCR` 加 `EXPIRE`。优点是实现简单，缺点是有**临界突刺**问题，可能导致瞬间流量超标。
>
> 2.  **比较精准的是滑动窗口：** 利用 Redis 的 **ZSet**，将请求时间戳作为 Score。每次请求先移除窗口外的数据，再统计当前数量。优点是精准，但缺点是**消耗内存大**，不适合高并发的大流量限流。
>
> 3.  **最优方案是令牌桶算法 + Lua 脚本：**（重点！）
>     我们通常使用 **Lua 脚本** 来保证操作的原子性。逻辑是：计算时间差，按速率向桶里‘添加’令牌，然后判断剩余令牌够不够。
>     这种方式既支持**弹性应对突发流量**（因为桶有容量），又因为 Lua 脚本在 Redis 内部执行，减少了网络开销且保证了线程安全。
>     在生产环境中，我们一般直接使用 **Redisson** 的 `RRateLimiter`，它内部就是基于令牌桶 Lua 脚本实现的。"

---

**这个回答完美覆盖了：原理、缺陷、原子性、工程实践。**

既然我们刚才反复提到了 **Lua 脚本的原子性** 和 **Redis 的数据存储**。
这里隐藏着一个巨大的危机：
**“Redis 确实很快，但如果 Redis 突然挂了，我们限流的计数器、用户的 Session、秒杀的库存不就全丢了吗？Redis 到底是怎么把数据存到硬盘上的？”**

（这是下一关的入口：**RDB vs AOF**，这可是 Redis 的半壁江山，准备好深入了吗？）